{"repo_name":"Kongsea\/tensorflow","path":"tensorflow\/python\/ops\/tensor_array_ops.py","copies":"10","size":"37283","content":"# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"TensorArray: a dynamically sized array of Tensors.\n\n@@TensorArray\n\"\"\"\n# Mixture of pep8 and non-pep8 names, so disable pylint bad-name\n# pylint: disable=g-bad-name\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport contextlib\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import tensor_shape\nfrom tensorflow.python.framework import tensor_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_data_flow_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.util import tf_should_use\n\n\n# _GraphTensorArray accesses many of the hidden generated ops, but is in\n# fact built to wrap these methods.\n# pylint: disable=protected-access\nclass _GraphTensorArray(object):\n  \"\"\"Graph-mode implementation of TensorArray.\n  \"\"\"\n\n  def __init__(self,\n               dtype,\n               size=None,\n               dynamic_size=None,\n               clear_after_read=None,\n               tensor_array_name=None,\n               handle=None,\n               flow=None,\n               infer_shape=True,\n               element_shape=None,\n               colocate_with_first_write_call=True,\n               name=None):\n    \"\"\"Constructs a graph mode TensorArray.\n\n    Args:\n      dtype: (required) data type of the TensorArray.\n      size: (optional) int32 scalar `Tensor`: the size of the TensorArray.\n        Required if handle is not provided.\n      dynamic_size: (optional) Python bool: If true, writes to the TensorArray\n        can grow the TensorArray past its initial size.  Default: False.\n      clear_after_read: Boolean (optional, default: True).  If True, clear\n        TensorArray values after reading them.  This disables read-many\n        semantics, but allows early release of memory.\n      tensor_array_name: (optional) Python string: the name of the TensorArray.\n        This is used when creating the TensorArray handle.  If this value is\n        set, handle should be None.\n      handle: (optional) A `Tensor` handle to an existing TensorArray.  If this\n        is set, tensor_array_name should be None. Only supported in graph mode.\n      flow: (optional) A float `Tensor` scalar coming from an existing\n        `TensorArray.flow`. Only supported in graph mode.\n      infer_shape: (optional, default: True) If True, shape inference\n        is enabled.  In this case, all elements must have the same shape.\n      element_shape: (optional, default: None) A `TensorShape` object specifying\n        the shape constraints of each of the elements of the TensorArray.\n        Need not be fully defined.\n      colocate_with_first_write_call: If `True`, the TensorArray will be\n        colocated on the same device as the Tensor used on its first write\n        (write operations include `write`, `unstack`, and `split`).  If `False`,\n        the TensorArray will be placed on the device determined by the\n        device context available during its initialization.\n      name: A name for the operation (optional).\n\n    Raises:\n      ValueError: if both handle and tensor_array_name are provided.\n      TypeError: if handle is provided but is not a Tensor.\n    \"\"\"\n    if handle is not None and tensor_array_name:\n      raise ValueError(\n          \"Cannot construct with both handle and tensor_array_name\")\n    if handle is not None and not isinstance(handle, ops.Tensor):\n      raise TypeError(\"Handle must be a Tensor\")\n    if handle is None and size is None:\n      raise ValueError(\"Size must be provided if handle is not provided\")\n    if handle is not None and size is not None:\n      raise ValueError(\"Cannot provide both a handle and size \"\n                       \"at the same time\")\n    if handle is not None and element_shape is not None:\n      raise ValueError(\"Cannot provide both a handle and element_shape \"\n                       \"at the same time\")\n    if handle is not None and dynamic_size is not None:\n      raise ValueError(\"Cannot provide both a handle and dynamic_size \"\n                       \"at the same time\")\n    if handle is not None and clear_after_read is not None:\n      raise ValueError(\"Cannot provide both a handle and clear_after_read \"\n                       \"at the same time\")\n\n    if clear_after_read is None:\n      clear_after_read = True\n    dynamic_size = dynamic_size or False\n\n    self._dtype = dtype\n\n    # Used to keep track of what tensors the TensorArray should be\n    # colocated with.  We choose to colocate the TensorArray with the\n    # first tensor written to it.\n    self._colocate_with_first_write_call = colocate_with_first_write_call\n    if colocate_with_first_write_call:\n      self._colocate_with = []\n    else:\n      self._colocate_with = None\n\n    # Record the current static shape for the array elements. The element\n    # shape is defined either by `element_shape` or the shape of the tensor\n    # of the first write. If `infer_shape` is true, all writes checks for\n    # shape equality.\n    if element_shape is None:\n      self._infer_shape = infer_shape\n      self._element_shape = []\n    else:\n      self._infer_shape = True\n      self._element_shape = [tensor_shape.TensorShape(element_shape)]\n    with ops.name_scope(name, \"TensorArray\", [handle, size, flow]) as scope:\n      if handle is not None:\n        self._handle = handle\n        if flow is None:\n          raise ValueError(\"flow must not be None if handle is not None.\")\n        self._flow = flow\n      else:\n        # Construct the TensorArray with an empty device.  The first\n        # write into the TensorArray from a Tensor with a set device\n        # will retroactively set the device value of this op.\n        def create():\n          \"\"\"Create the TensorArray op.\"\"\"\n          return gen_data_flow_ops._tensor_array_v3(\n              dtype=dtype,\n              size=size,\n              element_shape=element_shape,\n              identical_element_shapes=infer_shape,\n              dynamic_size=dynamic_size,\n              clear_after_read=clear_after_read,\n              tensor_array_name=tensor_array_name,\n              name=scope)\n        if colocate_with_first_write_call:\n          with ops.device(None), ops.colocate_with(None, ignore_existing=True):\n            self._handle, self._flow = create()\n        else:\n          self._handle, self._flow = create()\n\n  @property\n  def flow(self):\n    return self._flow\n\n  @property\n  def dtype(self):\n    return self._dtype\n\n  @property\n  def handle(self):\n    return self._handle\n\n  def _merge_element_shape(self, shape):\n    \"\"\"Changes the element shape of the array given a shape to merge with.\n\n    Args:\n      shape: A `TensorShape` object to merge with.\n\n    Raises:\n      ValueError: if the provided shape is incompatible with the current\n          element shape of the `TensorArray`.\n    \"\"\"\n\n    if self._element_shape:\n      if not shape.is_compatible_with(self._element_shape[0]):\n        raise ValueError(\n            \"Inconsistent shapes: saw %s but expected %s \"\n            \"(and infer_shape=True)\" % (shape, self._element_shape[0]))\n      self._element_shape[0] = self._element_shape[0].merge_with(shape)\n    else:\n      self._element_shape.append(shape)\n\n  @contextlib.contextmanager\n  def _maybe_colocate_with(self, value):\n    \"\"\"Colocate operations with an internal colocation group or `value`.\n\n    Args:\n      value: `Tensor`, the tensor to try to colocate with.\n\n    Yields:\n      Does not yield anything, but the new context is a colocation context.\n\n    If no internal colocation group is set, colocate with `value` and set\n    the internal colocation group to be value.\n    \"\"\"\n    if not self._colocate_with_first_write_call:\n      yield\n    else:\n      if not self._colocate_with:\n        self._colocate_with.append(value)\n      with ops.colocate_with(self._colocate_with[0]):\n        yield\n\n  def identity(self):\n    \"\"\"See TensorArray.\"\"\"\n    flow = array_ops.identity(self._flow)\n    ta = TensorArray(\n        dtype=self._dtype, handle=self._handle, flow=flow,\n        infer_shape=self._infer_shape,\n        colocate_with_first_write_call=self._colocate_with_first_write_call)\n    ta._element_shape = self._element_shape\n    ta._colocate_with = self._colocate_with\n    return ta\n\n  def grad(self, source, flow=None, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    # tensor_array_grad requires a flow input when forward\n    # TensorArrays are dynamically sized.  This forces the creation\n    # of the grad TensorArray only once the final forward array's size\n    # is fixed.\n    if flow is None:\n      flow = self.flow\n    with ops.name_scope(name, \"TensorArrayGrad\", [self._handle]):\n      with ops.colocate_with(self._handle):\n        g_handle, unused_flow = gen_data_flow_ops._tensor_array_grad_v3(\n            handle=self._handle, source=source, flow_in=flow, name=name)\n        with ops.control_dependencies([g_handle]):\n          flow = array_ops.identity(flow, name=\"gradient_flow\")\n        g = TensorArray(\n            dtype=self._dtype,\n            handle=g_handle,\n            flow=flow,\n            infer_shape=self._infer_shape,\n            colocate_with_first_write_call=False)\n        g._element_shape = self._element_shape\n        return g\n\n  def read(self, index, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    value = gen_data_flow_ops._tensor_array_read_v3(\n        handle=self._handle,\n        index=index,\n        flow_in=self._flow,\n        dtype=self._dtype,\n        name=name)\n    if self._element_shape:\n      value.set_shape(self._element_shape[0].dims)\n    return value\n\n  @tf_should_use.should_use_result\n  def write(self, index, value, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    with ops.name_scope(name, \"TensorArrayWrite\", [self._handle, index, value]):\n      value = ops.convert_to_tensor(value, name=\"value\")\n      if self._infer_shape:\n        self._merge_element_shape(value.shape)\n      with self._maybe_colocate_with(value):\n        flow_out = gen_data_flow_ops._tensor_array_write_v3(\n            handle=self._handle,\n            index=index,\n            value=value,\n            flow_in=self._flow,\n            name=name)\n      ta = TensorArray(\n          dtype=self._dtype, handle=self._handle, flow=flow_out,\n          colocate_with_first_write_call=self._colocate_with_first_write_call)\n      ta._infer_shape = self._infer_shape\n      ta._element_shape = self._element_shape\n      ta._colocate_with = self._colocate_with\n      return ta\n\n  def stack(self, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    with ops.colocate_with(self._handle):\n      with ops.name_scope(name, \"TensorArrayStack\", [self._handle]):\n        return self.gather(math_ops.range(0, self.size()), name=name)\n\n  def gather(self, indices, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    if self._element_shape:\n      element_shape = self._element_shape[0]\n    else:\n      element_shape = tensor_shape.TensorShape(None)\n    value = gen_data_flow_ops._tensor_array_gather_v3(\n        handle=self._handle,\n        indices=indices,\n        flow_in=self._flow,\n        dtype=self._dtype,\n        name=name,\n        element_shape=element_shape)\n    if self._element_shape and self._element_shape[0].dims is not None:\n      value.set_shape([None] + self._element_shape[0].dims)\n    return value\n\n  def concat(self, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    if self._element_shape and self._element_shape[0].dims is not None:\n      element_shape_except0 = (\n          tensor_shape.TensorShape(self._element_shape[0].dims[1:]))\n    else:\n      element_shape_except0 = tensor_shape.TensorShape(None)\n    value, _ = gen_data_flow_ops._tensor_array_concat_v3(\n        handle=self._handle,\n        flow_in=self._flow,\n        dtype=self._dtype,\n        name=name,\n        element_shape_except0=element_shape_except0)\n    if self._element_shape and self._element_shape[0].dims is not None:\n      value.set_shape([None] + self._element_shape[0].dims[1:])\n    return value\n\n  @tf_should_use.should_use_result\n  def unstack(self, value, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    with ops.name_scope(name, \"TensorArrayUnstack\", [self._handle, value]):\n      num_elements = array_ops.shape(value)[0]\n      return self.scatter(\n          indices=math_ops.range(0, num_elements), value=value, name=name)\n\n  @tf_should_use.should_use_result\n  def scatter(self, indices, value, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    with ops.name_scope(name, \"TensorArrayScatter\",\n                        [self._handle, value, indices]):\n      value = ops.convert_to_tensor(value, name=\"value\")\n      if self._infer_shape and context.in_graph_mode():\n        self._merge_element_shape(value.shape[1:])\n      with self._maybe_colocate_with(value):\n        flow_out = gen_data_flow_ops._tensor_array_scatter_v3(\n            handle=self._handle,\n            indices=indices,\n            value=value,\n            flow_in=self._flow,\n            name=name)\n      ta = TensorArray(\n          dtype=self._dtype, handle=self._handle, flow=flow_out,\n          colocate_with_first_write_call=self._colocate_with_first_write_call)\n      ta._infer_shape = self._infer_shape\n      ta._element_shape = self._element_shape\n      ta._colocate_with = self._colocate_with\n      return ta\n\n  @tf_should_use.should_use_result\n  def split(self, value, lengths, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    with ops.name_scope(name, \"TensorArraySplit\",\n                        [self._handle, value, lengths]):\n      value = ops.convert_to_tensor(value, name=\"value\")\n      with self._maybe_colocate_with(value):\n        lengths_64 = math_ops.to_int64(lengths)\n        if self._infer_shape and context.in_graph_mode():\n          clengths = tensor_util.constant_value(lengths_64)\n          if value.shape.dims is not None:\n            if clengths is not None and clengths.max() == clengths.min():\n              self._merge_element_shape(\n                  tensor_shape.TensorShape([clengths[0]]).concatenate(\n                      value.shape[1:]))\n        flow_out = gen_data_flow_ops._tensor_array_split_v3(\n            handle=self._handle,\n            value=value,\n            lengths=lengths_64,\n            flow_in=self._flow,\n            name=name)\n      ta = TensorArray(\n          dtype=self._dtype, handle=self._handle, flow=flow_out,\n          colocate_with_first_write_call=self._colocate_with_first_write_call)\n      ta._infer_shape = self._infer_shape\n      ta._element_shape = self._element_shape\n      ta._colocate_with = self._colocate_with\n      return ta\n\n  def size(self, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    return gen_data_flow_ops._tensor_array_size_v3(\n        handle=self._handle, flow_in=self.flow, name=name)\n\n  @tf_should_use.should_use_result\n  def close(self, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    return gen_data_flow_ops._tensor_array_close_v3(\n        handle=self._handle, name=name)\n\n# pylint: enable=protected-access\n\n\n# pylint: disable=protected-access\ndef _eager_write_no_copy(ta, index, value):\n  \"\"\"Writes value into an _EagerTensorArray without creating a new TensorArray.\n\n  Args:\n    ta: _EagerTensorArray into which to write value.\n    index: 0-D.  int32 scalar with the index to write to.\n    value: N-D.  Tensor of type `dtype`.  The Tensor to write to this index.\n\n  Raises:\n    errors_impl.AlreadyExistsError: attempting to overwrite an entry.\n    errors_impl.InvalidArgumentError: value dtype does not match `ta`'s dtype.\n    errors_impl.OutOfRangeError: `index` is out of bounds.\n    ValueError: shape of `value` is not consistent with inferred shape.\n  \"\"\"\n\n  if isinstance(index, ops.EagerTensor):\n    index = index.numpy()\n\n  if index < 0:\n    raise errors_impl.OutOfRangeError(\n        None, None,\n        \"Writing to negative indices (index %d) is not allowed.\" % index)\n\n  tensor_array = ta._tensor_array\n  size = len(tensor_array)\n  if index >= size:\n    if not ta._dynamic_size:\n      raise errors_impl.OutOfRangeError(\n          None, None,\n          \"Tried to write to index %d but array is not resizeable and size \"\n          \"is: %d\" % (index, size))\n    tensor_array.extend([None for _ in range(index - size + 1)])\n\n  if not isinstance(value, ops.EagerTensor):\n    value = constant_op.constant(value)\n\n  if ta._infer_shape:\n    if ta._element_shape is None:\n      ta._element_shape = value.shape\n    elif ta._element_shape != value.shape:\n      raise ValueError(\"Incompatible shape for value (%s), expected (%s)\" %\n                       (value.shape.as_list(), ta._element_shape.as_list()))\n\n  if ta._dtype != value.dtype:\n    raise errors_impl.InvalidArgumentError(\n        None, None,\n        \"TensorArray dtype is %s but Op is trying to write dtype %s\" %\n        (ta._dtype.name, value.dtype.name))\n\n  if ta._tensor_array[index] is not None:\n    raise errors_impl.AlreadyExistsError(\n        None, None,\n        \"Could not write to TensorArray index %d because it has already been \"\n        \"written to.\" % index)\n\n  tensor_array[index] = value\n\n# pylint: enable=protected-access\n\n\nclass _EagerTensorArray(object):\n  \"\"\"Eager-mode implementation of TensorArray.\n  \"\"\"\n\n  def __init__(self,\n               dtype,\n               size=None,\n               dynamic_size=None,\n               clear_after_read=None,\n               tensor_array_name=None,\n               handle=None,\n               flow=None,\n               infer_shape=True,\n               element_shape=None,\n               colocate_with_first_write_call=True,\n               name=None):\n    \"\"\"Constructs an Eager mode TensorArray.\n\n    Args:\n      dtype: (required) data type of the TensorArray.\n      size: (optional) int32 scalar `Tensor`: the size of the TensorArray.\n        Required if handle is not provided.\n      dynamic_size: (optional) Python bool: If true, writes to the TensorArray\n        can grow the TensorArray past its initial size.  Default: False.\n      clear_after_read: Boolean (optional, default: True).  If True, clear\n        TensorArray values after reading them.  This disables read-many\n        semantics, but allows early release of memory.\n      tensor_array_name: unused.\n      handle: unsupported.\n      flow: unsupported.\n      infer_shape: used for error checking, same semantics as TensorArray.\n      element_shape: used for error checking, same semantics as TensorArray.\n      colocate_with_first_write_call: unsupported.\n      name: unsupported.\n\n    Raises:\n      ValueError: handle or flow are supplied, or if size is not supplied.\n    \"\"\"\n\n    del (flow, tensor_array_name, name)  # not meaningful in Eager\n\n    if handle is not None:\n      raise ValueError(\"TensorArray handles are not supported in Eager mode.\")\n    if size is None:\n      raise ValueError(\"Size must be declared for TensorArrays in Eager mode.\")\n\n    # These attributes are not meaningful in Eager, but some library functions\n    # (e.g., those in control_flow_ops.py) access them to create new tensor\n    # arrays; as such, we define them for the sake of compatibility.\n    self._handle = None\n    # we assign a dummy value to _flow in case other code assumes it to be\n    # a Tensor\n    self._flow = constant_op.constant(0, dtype=dtypes.int32)\n    self._infer_shape = infer_shape\n    self._element_shape = element_shape\n    self._colocate_with_first_write_call = colocate_with_first_write_call\n\n    self._dtype = dtype\n    self._dynamic_size = dynamic_size or False\n    self._clear_after_read = (\n        True if clear_after_read is None else clear_after_read)\n    self._previously_read_indices = []\n\n    if isinstance(size, ops.EagerTensor):\n      size = size.numpy()\n    self._tensor_array = [None for _ in range(size)]\n\n  @property\n  def flow(self):\n    \"\"\"Flows are not meaningful in Eager; this exists for compatibility.\"\"\"\n    return self._flow\n\n  @property\n  def dtype(self):\n    return self._dtype\n\n  @property\n  def handle(self):\n    \"\"\"Handles are not meaningful in Eager; this exists for compatibility.\"\"\"\n    return self._handle\n\n  def _identity_without_array(self):\n    \"\"\"Returns a new TensorArray with the same properties as this Eager one.\n\n    NB: Does not set the underlying _tensor_array attribute.\n    \"\"\"\n    ta = TensorArray(\n        dtype=self._dtype,\n        size=len(self._tensor_array),\n        dynamic_size=self._dynamic_size,\n        clear_after_read=self._clear_after_read,\n        handle=self._handle,\n        flow=self._flow,\n        infer_shape=self._infer_shape,\n        element_shape=self._element_shape,\n        colocate_with_first_write_call=self._colocate_with_first_write_call)\n    ta._implementation._previously_read_indices = self._previously_read_indices  # pylint: disable=protected-access\n    return ta\n\n  def identity(self):\n    \"\"\"See TensorArray.\"\"\"\n    ta = self._identity_without_array()\n    ta._implementation._tensor_array = [t for t in self._tensor_array]  # pylint: disable=protected-access\n    return ta\n\n  def grad(self, source, flow=None, name=None):\n    raise NotImplementedError(\n        \"TensorArray.grad is not supported in Eager mode; Eager's gradient \"\n        \"implementation does not use\/need this function to compute gradients \"\n        \"of operations that use TensorArrays.\")\n\n  def read(self, index, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    del name  # not meaningful in Eager mode\n\n    if isinstance(index, ops.EagerTensor):\n      index = index.numpy()\n\n    if index < 0:\n      raise errors_impl.OutOfRangeError(\n          None, None,\n          \"Reading from negative indices (index %d) is not allowed.\" % index)\n\n    if index >= len(self._tensor_array):\n      raise errors_impl.OutOfRangeError(\n          None, None, \"Tried to read from index %d but array size is: %d\" %\n          (index, len(self._tensor_array)))\n\n    tensor = self._tensor_array[index]\n    if tensor is None:\n      if index in self._previously_read_indices:\n        raise errors_impl.InvalidArgumentError(\n            None, None,\n            \"Could not read index %d twice because it was cleared after \"\n            \"a previous read (perhaps try setting clear_after_read = false?)\" %\n            index)\n      else:\n        tensor = self._maybe_zero(index)\n\n    if self._clear_after_read:\n      self._tensor_array[index] = None\n      self._previously_read_indices.append(index)\n    return tensor\n\n  def write(self, index, value, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    del name  # not meaningful in Eager mode\n    ta = self.identity()\n    _eager_write_no_copy(ta._implementation, index, value)  # pylint: disable=protected-access\n    return ta\n\n  def _maybe_zero(self, ix):\n    val = self._tensor_array[ix]\n    if val is None:\n      val = self._tensor_array[ix] = array_ops.zeros(\n          shape=self._element_shape, dtype=self._dtype)\n    return val\n\n  def stack(self, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    if self._tensor_array:\n      for ix in range(len(self._tensor_array)):\n        self._maybe_zero(ix)\n    return array_ops.stack(self._tensor_array, name=name)\n\n  def gather(self, indices, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    del name  # not meaningful in Eager mode\n    return array_ops.stack([self._maybe_zero(i) for i in indices.numpy()])\n\n  def concat(self, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    try:\n      return array_ops.concat(\n          [self._maybe_zero(ix) for ix in range(len(self._tensor_array))],\n          0, name=name)\n    except errors_impl.OpError:\n      # Reproduce a subset of the error-handling for graph-mode TensorArrays.\n      shapes = [t.shape for t in self._tensor_array]\n      ndims = [s.ndims for s in shapes]\n      if 0 in ndims:\n        idx = ndims.index(0)\n        raise errors_impl.InvalidArgumentError(\n            None, None, \"Concat saw a scalar shape at index %d but requires \"\n            \"at least vectors.\" % idx)\n      else:\n        raise\n\n  def unstack(self, value, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    tensors = array_ops.unstack(value, name=name)\n    if len(tensors) > len(self._tensor_array) and not self._dynamic_size:\n      raise ValueError(\n          \"Cannot unstack %d tensors into a TensorArray of static size %d\" %\n          (len(tensors), len(self._tensors)))\n    ta = self._identity_without_array()\n    ta._implementation._tensor_array = tensors  # pylint: disable=protected-access\n    return ta\n\n  def scatter(self, indices, value, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    del name  # unused in Eager\n    ta = self.identity()\n    for index, val in zip(indices.numpy(), array_ops.unstack(value)):\n      _eager_write_no_copy(ta._implementation, index, val)  # pylint: disable=protected-access\n    return ta\n\n  def split(self, value, lengths, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    # error checking to match graph-mode errors\n    value = constant_op.constant(value)\n    lengths = constant_op.constant(lengths)\n    sum_lengths = math_ops.reduce_sum(lengths)\n    if lengths.shape.ndims != 1:\n      raise errors_impl.InvalidArgumentError(\n          None, None, \"Expected lengths to be a vector, received shape: %s\" %\n          lengths.shape.as_list())\n    elif value.shape.ndims == 0:\n      raise errors_impl.InvalidArgumentError(\n          None, None, \"Expected value to be at least a vector, \"\n          \"but received shape: %s\" % value.shape.as_list())\n    elif sum_lengths.numpy() != value.shape.as_list()[0]:\n      raise errors_impl.InvalidArgumentError(\n          None, None, \"Expected sum of lengths to be equal to \"\n          \"values.shape[0], but sum of lengths is %d and \"\n          \"value's shape is: %s \" % (sum_lengths.numpy(),\n                                     value.shape.as_list()))\n    elif not self._dynamic_size and lengths.shape[0] != len(self._tensor_array):\n      raise errors_impl.InvalidArgumentError(\n          None, None, \"TensorArray's size is not equal to the size of \"\n          \"lengths (%d vs. %d), and the TensorArray is not marked as \"\n          \"dynamically resizeable\" % (len(self._tensor_array),\n                                      lengths.shape[0]))\n    else:\n      ta = self._identity_without_array()\n      tensor_array = array_ops.split(value, lengths, name=name)\n      ta._implementation._tensor_array = tensor_array  # pylint: disable=protected-access\n      return ta\n\n  def size(self, name=None):\n    \"\"\"See TensorArray.\"\"\"\n    del name  # not meaningful in Eager mode\n    return constant_op.constant(len(self._tensor_array))\n\n  def close(self, name=None):\n    del name  # not meaningful in Eager mode\n    del self._tensor_array[:]\n    return\n\n\n# TensorArray is designed to hide an underlying implementation object\n# and as such accesses many of that object's hidden fields.\n# pylint: disable=protected-access\nclass TensorArray(object):\n  \"\"\"Class wrapping dynamic-sized, per-time-step, write-once Tensor arrays.\n\n  This class is meant to be used with dynamic iteration primitives such as\n  `while_loop` and `map_fn`.  It supports gradient back-propagation via special\n  \"flow\" control flow dependencies.\n  \"\"\"\n\n  def __init__(self,\n               dtype,\n               size=None,\n               dynamic_size=None,\n               clear_after_read=None,\n               tensor_array_name=None,\n               handle=None,\n               flow=None,\n               infer_shape=True,\n               element_shape=None,\n               colocate_with_first_write_call=True,\n               name=None):\n    \"\"\"Construct a new TensorArray or wrap an existing TensorArray handle.\n\n    A note about the parameter `name`:\n\n    The name of the `TensorArray` (even if passed in) is uniquified: each time\n    a new `TensorArray` is created at runtime it is assigned its own name for\n    the duration of the run.  This avoids name collisions if a `TensorArray`\n    is created within a `while_loop`.\n\n    Args:\n      dtype: (required) data type of the TensorArray.\n      size: (optional) int32 scalar `Tensor`: the size of the TensorArray.\n        Required if handle is not provided.\n      dynamic_size: (optional) Python bool: If true, writes to the TensorArray\n        can grow the TensorArray past its initial size.  Default: False.\n      clear_after_read: Boolean (optional, default: True).  If True, clear\n        TensorArray values after reading them.  This disables read-many\n        semantics, but allows early release of memory.\n      tensor_array_name: (optional) Python string: the name of the TensorArray.\n        This is used when creating the TensorArray handle.  If this value is\n        set, handle should be None.\n      handle: (optional) A `Tensor` handle to an existing TensorArray.  If this\n        is set, tensor_array_name should be None. Only supported in graph mode.\n      flow: (optional) A float `Tensor` scalar coming from an existing\n        `TensorArray.flow`. Only supported in graph mode.\n      infer_shape: (optional, default: True) If True, shape inference\n        is enabled.  In this case, all elements must have the same shape.\n      element_shape: (optional, default: None) A `TensorShape` object specifying\n        the shape constraints of each of the elements of the TensorArray.\n        Need not be fully defined.\n      colocate_with_first_write_call: If `True`, the TensorArray will be\n        colocated on the same device as the Tensor used on its first write\n        (write operations include `write`, `unstack`, and `split`).  If `False`,\n        the TensorArray will be placed on the device determined by the\n        device context available during its initialization.\n      name: A name for the operation (optional).\n\n    Raises:\n      ValueError: if both handle and tensor_array_name are provided.\n      TypeError: if handle is provided but is not a Tensor.\n    \"\"\"\n    if context.in_graph_mode():\n      implementation = _GraphTensorArray\n    else:\n      implementation = _EagerTensorArray\n\n    self._implementation = implementation(\n        dtype,\n        size=size,\n        dynamic_size=dynamic_size,\n        clear_after_read=clear_after_read,\n        tensor_array_name=tensor_array_name,\n        handle=handle,\n        flow=flow,\n        infer_shape=infer_shape,\n        element_shape=element_shape,\n        colocate_with_first_write_call=colocate_with_first_write_call,\n        name=name)\n\n  @property\n  def flow(self):\n    \"\"\"The flow `Tensor` forcing ops leading to this TensorArray state.\"\"\"\n    return self._implementation._flow\n\n  @property\n  def dtype(self):\n    \"\"\"The data type of this TensorArray.\"\"\"\n    return self._implementation._dtype\n\n  @property\n  def handle(self):\n    \"\"\"The reference to the TensorArray.\"\"\"\n    return self._implementation._handle\n\n  @property\n  def _infer_shape(self):\n    return self._implementation._infer_shape\n\n  @_infer_shape.setter\n  def _infer_shape(self, infer_shape):\n    self._implementation._infer_shape = infer_shape\n\n  @property\n  def _element_shape(self):\n    return self._implementation._element_shape\n\n  @_element_shape.setter\n  def _element_shape(self, element_shape):\n    self._implementation._element_shape = element_shape\n\n  @property\n  def _colocate_with_first_write_call(self):\n    return self._implementation._colocate_with_first_write_call\n\n  @property\n  def _colocate_with(self):\n    return self._implementation._colocate_with\n\n  @_colocate_with.setter\n  def _colocate_with(self, colocate_with):\n    self._implementation._colocate_with = colocate_with\n\n  def identity(self):\n    \"\"\"Returns a TensorArray with the same content and properties.\n\n    Returns:\n      A new TensorArray object with flow that ensures the control dependencies\n      from the contexts will become control dependencies for writes, reads, etc.\n      Use this object all for subsequent operations.\n    \"\"\"\n    return self._implementation.identity()\n\n  def grad(self, source, flow=None, name=None):\n    return self._implementation.grad(source, flow=flow, name=name)\n\n  def read(self, index, name=None):\n    \"\"\"Read the value at location `index` in the TensorArray.\n\n    Args:\n      index: 0-D.  int32 tensor with the index to read from.\n      name: A name for the operation (optional).\n\n    Returns:\n      The tensor at index `index`.\n    \"\"\"\n    return self._implementation.read(index, name=name)\n\n  @tf_should_use.should_use_result\n  def write(self, index, value, name=None):\n    \"\"\"Write `value` into index `index` of the TensorArray.\n\n    Args:\n      index: 0-D.  int32 scalar with the index to write to.\n      value: N-D.  Tensor of type `dtype`.  The Tensor to write to this index.\n      name: A name for the operation (optional).\n\n    Returns:\n      A new TensorArray object with flow that ensures the write occurs.\n      Use this object all for subsequent operations.\n\n    Raises:\n      ValueError: if there are more writers than specified.\n    \"\"\"\n    return self._implementation.write(index, value, name=name)\n\n  def stack(self, name=None):\n    \"\"\"Return the values in the TensorArray as a stacked `Tensor`.\n\n    All of the values must have been written and their shapes must all match.\n    If input shapes have rank-`R`, then output shape will have rank-`(R+1)`.\n\n    Args:\n      name: A name for the operation (optional).\n\n    Returns:\n      All the tensors in the TensorArray stacked into one tensor.\n    \"\"\"\n    return self._implementation.stack(name=name)\n\n  def gather(self, indices, name=None):\n    \"\"\"Return selected values in the TensorArray as a packed `Tensor`.\n\n    All of selected values must have been written and their shapes\n    must all match.\n\n    Args:\n      indices: A `1-D` `Tensor` taking values in `[0, max_value)`.  If\n        the `TensorArray` is not dynamic, `max_value=size()`.\n      name: A name for the operation (optional).\n\n    Returns:\n      The tensors in the `TensorArray` selected by `indices`, packed into one\n      tensor.\n    \"\"\"\n    return self._implementation.gather(indices, name=name)\n\n  def concat(self, name=None):\n    \"\"\"Return the values in the TensorArray as a concatenated `Tensor`.\n\n    All of the values must have been written, their ranks must match, and\n    and their shapes must all match for all dimensions except the first.\n\n    Args:\n      name: A name for the operation (optional).\n\n    Returns:\n      All the tensors in the TensorArray concatenated into one tensor.\n    \"\"\"\n    return self._implementation.concat(name=name)\n\n  @tf_should_use.should_use_result\n  def unstack(self, value, name=None):\n    \"\"\"Unstack the values of a `Tensor` in the TensorArray.\n\n    If input value shapes have rank-`R`, then the output TensorArray will\n    contain elements whose shapes are rank-`(R-1)`.\n\n    Args:\n      value: (N+1)-D.  Tensor of type `dtype`.  The Tensor to unstack.\n      name: A name for the operation (optional).\n\n    Returns:\n      A new TensorArray object with flow that ensures the unstack occurs.\n      Use this object all for subsequent operations.\n\n    Raises:\n      ValueError: if the shape inference fails.\n    \"\"\"\n    return self._implementation.unstack(value, name=name)\n\n  @tf_should_use.should_use_result\n  def scatter(self, indices, value, name=None):\n    \"\"\"Scatter the values of a `Tensor` in specific indices of a `TensorArray`.\n\n    Args:\n      indices: A `1-D` `Tensor` taking values in `[0, max_value)`.  If\n        the `TensorArray` is not dynamic, `max_value=size()`.\n      value: (N+1)-D.  Tensor of type `dtype`.  The Tensor to unpack.\n      name: A name for the operation (optional).\n\n    Returns:\n      A new TensorArray object with flow that ensures the scatter occurs.\n      Use this object all for subsequent operations.\n\n    Raises:\n      ValueError: if the shape inference fails.\n    \"\"\"\n    return self._implementation.scatter(indices, value, name=name)\n\n  @tf_should_use.should_use_result\n  def split(self, value, lengths, name=None):\n    \"\"\"Split the values of a `Tensor` into the TensorArray.\n\n    Args:\n      value: (N+1)-D.  Tensor of type `dtype`.  The Tensor to split.\n      lengths: 1-D.  int32 vector with the lengths to use when splitting\n        `value` along its first dimension.\n      name: A name for the operation (optional).\n\n    Returns:\n      A new TensorArray object with flow that ensures the split occurs.\n      Use this object all for subsequent operations.\n\n    Raises:\n      ValueError: if the shape inference fails.\n    \"\"\"\n    return self._implementation.split(value, lengths, name=name)\n\n  def size(self, name=None):\n    \"\"\"Return the size of the TensorArray.\"\"\"\n    return self._implementation.size(name=name)\n\n  @tf_should_use.should_use_result\n  def close(self, name=None):\n    \"\"\"Close the current TensorArray.\"\"\"\n    return self._implementation.close(name=name)\n\n# pylint: enable=protected-access\n","license":"apache-2.0","hash":8129684556055904308,"line_mean":36.6215943491,"line_max":115,"alpha_frac":0.6528444599,"autogenerated":false}
{"repo_name":"Hpower96\/Power","path":"sbin\/batch_CMD.py","copies":"1","size":"1865","content":"#!\/usr\/bin\/env python\n# Author: Alex Li\nimport multiprocessing\nimport sys, os, time\nfrom backend import db_connector, logger, MultiRunCounter\n\n# ----------------Use Django Mysql model----------------\n\ncur_dir = os.path.dirname(os.path.abspath(__file__))\nscript = 'python %s\/run_command4.py' % cur_dir\n\ntry:\n    if sys.argv[1] == '-h':\n        print '''\\n\\033[32;1mUsage: python multiprocessing_runCMD.py track_num 'ip_list' cmd run_user\\033[0m\nExample: python multiprocessing_runCMD.py 34 '192.168.2.13 202.106.0.23 10.0.0.2' 'df -h' alex \\n\n--auto : auto add the track_mark\n\t.\/multiprocessing_runCMD2.py --auto '192.168.91.171 192.168.10.43 192.168.10.160 192.168.91.171' 'df -h' alex'''\n        sys.exit()\nexcept IndexError:\n    print \"argument error,try -h for help\"\n    sys.exit()\ntry:\n    if sys.argv[1] == \"--auto\":\n        track_num = MultiRunCounter.AddNumber()\n    else:\n        track_num = sys.argv[1]\nexcept IndexError:\n    print \"argument error,try -h for help\"\n    sys.exit()\n\nif __name__ == \"__main__\":\n    run_user = sys.argv[4]\n    raw_ip_list = sys.argv[2].split()\n    remove_duplicate_ip = set(raw_ip_list)\n    ip_list = list(remove_duplicate_ip)\n    cmd = sys.argv[3]\n\n    # batch run process\n    logger.RecordLogSummary('CREATE', 'BatchRunCommand', track_num, run_user, cmd, len(ip_list),\n                            '\/tmp\/opt_%s.log' % track_num)\n\n    result = []\n\n\n    def run(host):\n        task = '''%s %s '%s' %s %s''' % (script, host, cmd, run_user, track_num)\n        os.system(task)\n\n\n    if len(ip_list) < 50:\n        thread_num = len(ip_list)\n    else:\n        thread_num = 30\n    pool = multiprocessing.Pool(processes=thread_num)\n\n    for ip in ip_list:\n        result.append(pool.apply_async(run, (ip,)))\n    # time.sleep(5)\n    # pool.terminate()\n\n    pool.close()\n    pool.join()\n\n    for res in result:\n        res.get(timeout=5)\n","license":"gpl-3.0","hash":6229798122506446743,"line_mean":27.6923076923,"line_max":113,"alpha_frac":0.600536193,"autogenerated":false}
{"repo_name":"makhidkarun\/traveller_pyroute","path":"PyRoute\/StatCalculation.py","copies":"1","size":"14360","content":"\"\"\"\nCreated on Mar 17, 2014\n\n@author: tjoneslo\n\"\"\"\nimport logging\nimport math\nfrom wikistats import WikiStats\nfrom collections import OrderedDict, defaultdict\nfrom AllyGen import AllyGen\nfrom Star import UWPCodes\n\n\nclass Populations(object):\n    def __init__(self):\n        self.code = \"\"\n        self.homeworlds = []\n        self.count = 0\n        self.population = 0\n        \n    def add_population(self, population, homeworld):\n        self.count += 1\n        self.population += population\n        if homeworld:\n            self.homeworlds.append(homeworld)\n\n    def __lt__(self, other):\n        return self.population < other.population\n\nclass ObjectStatistics(object):\n    base_mapping = {'C':'Corsair base', 'D':'Naval depot', 'E': 'Embassy', 'K': 'Naval base', 'M': 'Military base',\n                    'N': 'Naval base', 'O': 'Naval outpost',\n                    'R': 'Clan base', 'S': 'Scout base', 'T':'Tlaukhu base', 'V': 'Scout base', 'W': 'Way station',\n                    '*': 'Unknown', 'I': 'Unknown',\n                    'G': 'Vargr Naval base',  'J': 'Naval base',\n                    'L': 'Hiver naval base', 'P': 'Droyne Naval base', 'Q': 'Droyne military garrison',\n                    'X': 'Zhodani relay station', 'Y': 'Zhodani depot',\n                    'A': 'Split', 'B': 'Split', 'F': 'Split','H': 'Split', 'U': 'Split', 'Z': 'Split' }\n\n    def __init__(self):\n        self.population = 0\n        self.populations = defaultdict(Populations)\n\n        self.economy = 0\n        self.trade = 0\n        self.tradeExt = 0\n        self.tradeVol = 0\n        self.percapita = 0\n        self.number = 0\n        self.milBudget = 0\n        self.maxTL = 0\n        self.maxPort = 'X'\n        self.maxPop = 0\n        self.sum_ru = 0\n        self.shipyards = 0\n        self.col_be = 0\n        self.im_be = 0\n        self.passengers = 0\n        self.spa_people = 0\n        self.port_size = defaultdict(int)\n        self.code_counts = defaultdict(int)\n        self.bases = defaultdict(int)\n        self.eti_worlds = 0\n        self.eti_cargo = 0\n        self.eti_pass = 0\n        self.homeworlds = []\n        self.high_pop_worlds = []\n        self.high_tech_worlds = []\n        self.TLmean = 0\n        self.TLstddev = 0\n        self.subsectorCp = []\n        self.sectorCp = []\n        self.otherCp = []\n        self.gg_count = 0\n        self.worlds = 0\n        self.stars = 0\n        self.star_count = defaultdict(int)\n        self.primary_count = defaultdict(int)\n\n    # For the JSONPickel work\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        del state['high_pop_worlds']\n        del state['high_tech_worlds']\n        del state['subsectorCp']\n        del state['sectorCp']\n        del state['otherCp']\n        del state['homeworlds']\n        return state\n    \n    def homeworld_count(self):\n        return len(self.homeworlds)\n\n    def high_pop_worlds_count(self):\n        return len(self.high_pop_worlds)\n\n    def high_pop_worlds_list(self):\n        return [world.wiki_name() for world in self.high_pop_worlds[0:6]]\n\n    def high_tech_worlds_count(self):\n        return len(self.high_tech_worlds)\n\n    def high_tech_worlds_list(self):\n        return [world.wiki_name() for world in self.high_tech_worlds[0:6]]\n\n    def populations_count(self):\n        return len(self.populations)\n\n\nclass UWPCollection(object):\n    def __init__(self):\n        self.uwp = OrderedDict()\n        for uwpCode in UWPCodes.uwpCodes:\n            self.uwp[uwpCode] = {}\n\n    def stats(self, code, value):\n        return self.uwp[code].setdefault(value, ObjectStatistics())\n\n    def __getitem__(self, index):\n        return self.uwp[index]\n\n    def __setitem__(self, index, value):\n        self.uwp[index] = value\n\n\nclass StatCalculation(object):\n    \"\"\"\n    Statistics calculations and output.\n    \"\"\"\n\n    def __init__(self, galaxy):\n        self.logger = logging.getLogger('PyRoute.StatCalculation')\n\n        self.galaxy = galaxy\n        self.all_uwp = UWPCollection()\n        self.imp_uwp = UWPCollection()\n\n    def calculate_statistics(self, ally_match):\n        self.logger.info('Calculating statistics for {:d} worlds'.format(len(self.galaxy.stars)))\n        for sector in self.galaxy.sectors.values():\n            if sector is None:\n                continue\n            for star in sector.worlds:\n                star.starportSize = max(self.trade_to_btn(star.tradeIn + star.tradeOver) - 5, 0)\n                star.uwpCodes['Starport Size'] = star.starportSize\n                # Budget in MCr\n                star.starportBudget = \\\n                    ((star.tradeIn \/\/ 10000) * 150 + (star.tradeOver \/\/ 10000) * 140 +\n                     (star.passIn) * 500 + (star.passOver) * 460) \/\/ 1000000\n\n                # Population in people employed.\n                star.starportPop = int(star.starportBudget \/ 0.2)\n\n                self.add_stats(sector.stats, star)\n                self.add_stats(self.galaxy.stats, star)\n                self.add_stats(sector.subsectors[star.subsector()].stats, star)\n\n                self.max_tl(sector.stats, star)\n                self.max_tl(sector.subsectors[star.subsector()].stats, star)\n\n                self.add_alg_stats(self.galaxy, star, star.alg_code)\n                self.add_alg_stats(sector, star, star.alg_code)\n                self.add_alg_stats(sector.subsectors[star.subsector()], star, star.alg_code)\n\n                if star.alg_base_code != star.alg_code:\n                    self.add_alg_stats(self.galaxy, star, star.alg_base_code)\n                    self.add_alg_stats(sector, star, star.alg_base_code)\n                    self.add_alg_stats(sector.subsectors[star.subsector()], star, star.alg_base_code)\n\n                if AllyGen.imperial_align(star.alg_code):\n                    for uwpCode, uwpValue in star.uwpCodes.items():\n                        self.add_stats(self.imp_uwp.stats(uwpCode, uwpValue), star)\n\n                for uwpCode, uwpValue in star.uwpCodes.items():\n                    self.add_stats(self.all_uwp.stats(uwpCode, uwpValue), star)\n\n            self.per_capita(sector.worlds, sector.stats)  # Per capita sector stats\n            sector.alg_sorted = AllyGen.sort_allegiances(sector.alg, ally_match)\n            for alg in sector.alg_sorted:\n                self.per_capita(alg.worlds, alg.stats)\n\n            for subsector in sector.subsectors.values():\n                self.per_capita(subsector.worlds, subsector.stats)\n                subsector.alg_sorted = AllyGen.sort_allegiances(subsector.alg, ally_match)\n                for alg in subsector.alg_sorted:\n                    self.per_capita(alg.worlds, alg.stats)\n\n        self.per_capita(None, self.galaxy.stats)\n\n        self.galaxy.alg_sorted = AllyGen.sort_allegiances(self.galaxy.alg, ally_match)\n        for alg in self.galaxy.alg_sorted:\n            self.per_capita(alg.worlds, alg.stats)\n\n        for uwpName in self.all_uwp.uwp.values():\n            for uwpStats in uwpName.values():\n                self.per_capita(None, uwpStats)\n\n        for uwpName in self.imp_uwp.uwp.values():\n            for uwpStats in uwpName.values():\n                self.per_capita(None, uwpStats)\n\n    def add_alg_stats(self, area, star, alg):\n        algStats = area.alg[alg].stats\n        self.add_stats(algStats, star)\n        self.max_tl(algStats, star)\n\n    def add_pop_to_sophont(self, stats, star):\n\n        total_pct = 100\n        default_soph = 'Huma'\n        home = None\n        for sophont in star.tradeCode.sophonts:\n            soph_code = sophont[0:4]\n            soph_pct = sophont[4:]\n\n            if soph_pct == 'A':\n                default_soph = soph_code\n                continue\n\n            soph_pct = 100.0 if soph_pct == 'W' else 0.0 if soph_pct in ['X', 'A'] else \\\n                5.0 if soph_pct == '0' else 10.0 * int(soph_pct)\n\n            if any([soph for soph in star.tradeCode.homeworld if soph.startswith(soph_code)]):\n                home = star\n\n            # Soph_pct == 'X' is dieback or extinct.\n            if soph_pct == 'X':\n                stats.populations[soph_code].population = -1\n            # skip the empty worlds\n            elif not star.tradeCode.barren:\n                stats.populations[soph_code].add_population(int(star.population * (soph_pct \/ 100.0)), home)\n\n            total_pct -= soph_pct\n\n        if total_pct < -5:\n            self.logger.warning(\"{} has sophont percent over 100%: {}\".format(star, total_pct))\n        elif total_pct < 0:\n            self.logger.info(\"{} has a sophont percent just over 100%: {}\".format(star, total_pct))\n        elif not star.tradeCode.barren:\n            stats.populations[default_soph].add_population(int(star.population * (total_pct \/ 100.0)), None)\n\n    def add_stats(self, stats, star):\n        stats.population += star.population\n\n        if star.tradeCode.homeworld:\n            stats.homeworlds.append(star)\n\n        self.add_pop_to_sophont(stats, star)\n\n        stats.economy += star.gwp\n        stats.number += 1\n        stats.sum_ru += star.ru\n        stats.shipyards += star.ship_capacity\n        stats.tradeVol += (star.tradeOver + star.tradeIn)\n        stats.col_be += star.col_be\n        stats.im_be += star.im_be\n        stats.passengers += star.passIn\n        stats.spa_people += star.starportPop\n        stats.port_size[star.starportSize] += 1\n        stats.port_size[star.port] += 1\n        for code in star.tradeCode.codes:\n            stats.code_counts[code] += 1\n        if star.ggCount:\n            stats.gg_count += 1\n\n        stats.worlds += star.worlds\n\n        if star.star_list:\n            stats.stars += len(star.star_list)\n            stats.star_count[len(star.star_list)] += 1\n            stats.primary_count[star.star_list[0][0]] += 1\n\n        for code in star.baseCode:\n            if code != '-':\n                if code == 'A':\n                    stats.bases[ObjectStatistics.base_mapping['N']] += 1\n                    stats.bases[ObjectStatistics.base_mapping['S']] += 1\n                elif code == 'B':\n                    stats.bases[ObjectStatistics.base_mapping['N']] += 1\n                    stats.bases[ObjectStatistics.base_mapping['W']] += 1\n                elif code == 'F':\n                    stats.bases[ObjectStatistics.base_mapping['K']] += 1\n                    stats.bases[ObjectStatistics.base_mapping['M']] += 1\n                elif code == 'H':\n                    stats.bases[ObjectStatistics.base_mapping['C']] += 1\n                    stats.bases[ObjectStatistics.base_mapping['K']] += 1\n                elif code == 'U':\n                    stats.bases[ObjectStatistics.base_mapping['T']] += 1\n                    stats.bases[ObjectStatistics.base_mapping['R']] += 1\n                elif code == 'Z':\n                    stats.bases[ObjectStatistics.base_mapping['K']] += 1\n                    stats.bases[ObjectStatistics.base_mapping['M']] += 1\n                else:\n                    stats.bases[ObjectStatistics.base_mapping[code]] += 1\n\n\n        if star.eti_cargo_volume > 0 or star.eti_pass_volume > 0:\n            stats.eti_worlds += 1\n        stats.eti_cargo += star.eti_cargo_volume\n        stats.eti_pass += star.eti_pass_volume\n\n    def max_tl(self, stats, star):\n        stats.maxTL = max(stats.maxTL, star.tl)\n        stats.maxPort = 'ABCDEX?'[min('ABCDEX?'.index(star.uwpCodes['Starport']), 'ABCDEX?'.index(stats.maxPort))]\n        stats.maxPop = max(stats.maxPop, star.popCode)\n\n    def per_capita(self, worlds, stats):\n        if stats.population > 100000:\n            stats.percapita = stats.economy \/\/ (stats.population \/\/ 1000)\n        elif stats.population > 0:\n            stats.percapita = stats.economy * 1000 \/\/ stats.population\n        else:\n            stats.percapita = 0\n\n        if stats.shipyards > 1000000:\n            stats.shipyards \/\/= 1000000\n        else:\n            stats.shipyards = 0\n        if worlds:\n            stats.high_pop_worlds = [world for world in worlds if world.popCode == stats.maxPop]\n            stats.high_pop_worlds.sort(key=lambda star: star.popM, reverse=True)\n            stats.high_tech_worlds = [world for world in worlds if world.tl == stats.maxTL]\n            stats.subsectorCp = [world for world in worlds if world.tradeCode.subsector_capital]\n            stats.sectorCp = [world for world in worlds if world.tradeCode.sector_capital]\n            stats.otherCp = [world for world in worlds if world.tradeCode.other_capital]\n\n            TLList = [world.tl for world in worlds]\n            if len(TLList) > 3:\n                stats.TLmean = sum(TLList) \/ len(TLList)\n                TLVar = [math.pow(tl - stats.TLmean, 2) for tl in TLList]\n                stats.TLstddev = math.sqrt(sum(TLVar) \/ len(TLVar))\n\n    def find_colonizer(self, world, owner_hex):\n        for target in self.galaxy.ranges.neighbors_iter(world):\n            if target.position == owner_hex:\n                target.tradeCode.append(\"C:{}-{}\".format(world.sector[0:4], world.position))\n                pass\n\n    def write_statistics(self, ally_count, ally_match, json_data):\n        self.logger.info('Charted star count: ' + str(self.galaxy.stats.number))\n        self.logger.info('Charted population {:,d}'.format(self.galaxy.stats.population))\n\n        if self.logger.isEnabledFor(logging.DEBUG):\n            for sector in self.galaxy.sectors.values():\n                self.logger.debug('Sector {} star count: {:,d}'.format(sector.name, sector.stats.number))\n\n            for code, aleg in self.galaxy.alg.items():\n                if aleg.base:\n                    s = 'Allegiance {0} ({1}: base {3}) star count: {2:,d}'.format(aleg.name, code, aleg.stats.number,\n                                                                                aleg.base)\n                else:\n                    s = 'Allegiance {0} ({1}: base {3} -> {4}) star count: {2:,d}'.format(aleg.name, code, aleg.stats.number,\n                                                                                aleg.base, AllyGen.same_align(aleg.code))\n                self.logger.debug(s)\n\n            self.logger.debug(\"min count: {}, match: {}\".format(ally_count, ally_match))\n\n        wiki = WikiStats(self.galaxy, self.all_uwp, ally_count, ally_match, json_data)\n        wiki.write_statistics()\n\n    @staticmethod\n    def trade_to_btn(trade):\n        if trade == 0:\n            return 0\n        return int(math.log(trade, 10))\n","license":"mit","hash":-1882234763052571367,"line_mean":38.3424657534,"line_max":125,"alpha_frac":0.5584261838,"autogenerated":false}
{"repo_name":"hoover\/search","path":"hoover\/search\/migrations\/0001_initial.py","copies":"1","size":"1170","content":"# -*- coding: utf-8 -*-\n# Generated by Django 1.10 on 2016-08-15 09:56\nfrom __future__ import unicode_literals\n\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name='Collection',\n            fields=[\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n                ('title', models.CharField(blank=True, max_length=2048)),\n                ('name', models.CharField(max_length=256, unique=True)),\n                ('index', models.CharField(max_length=256)),\n                ('public', models.BooleanField(default=False)),\n                ('loader', models.CharField(default='hoover.search.loaders.upload.Loader', max_length=2048)),\n                ('options', models.TextField(default='{}')),\n                ('users', models.ManyToManyField(blank=True, related_name='hoover_search_collections', to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n    ]\n","license":"mit","hash":-5133954938625101973,"line_mean":36.7419354839,"line_max":133,"alpha_frac":0.6076923077,"autogenerated":false}
{"repo_name":"gaddman\/ansible","path":"lib\/ansible\/plugins\/inventory\/openshift.py","copies":"10","size":"8248","content":"# Copyright (c) 2018 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https:\/\/www.gnu.org\/licenses\/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n\n__metaclass__ = type\n\nDOCUMENTATION = '''\n    name: openshift\n    plugin_type: inventory\n    author:\n      - Chris Houseknecht <@chouseknecht>\n\n    short_description: OpenShift inventory source\n\n    description:\n      - Fetch containers, services and routes for one or more clusters\n      - Groups by cluster name, namespace, namespace_services, namespace_pods, namespace_routes, and labels\n      - Uses openshift.(yml|yaml) YAML configuration file to set parameter values.\n\n    options:\n      plugin:\n        description: token that ensures this is a source file for the 'openshift' plugin.\n        required: True\n        choices: ['openshift']\n      connections:\n          description:\n          - Optional list of cluster connection settings. If no connections are provided, the default\n            I(~\/.kube\/config) and active context will be used, and objects will be returned for all namespaces\n            the active user is authorized to access.\n          name:\n              description:\n              - Optional name to assign to the cluster. If not provided, a name is constructed from the server\n                and port.\n          kubeconfig:\n              description:\n              - Path to an existing Kubernetes config file. If not provided, and no other connection\n                options are provided, the OpenShift client will attempt to load the default\n                configuration file from I(~\/.kube\/config.json). Can also be specified via K8S_AUTH_KUBECONFIG\n                environment variable.\n          context:\n              description:\n              - The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment\n                variable.\n          host:\n              description:\n              - Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.\n          api_key:\n              description:\n              - Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment\n                variable.\n          username:\n              description:\n              - Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME\n                environment variable.\n          password:\n              description:\n              - Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD\n                environment variable.\n          cert_file:\n              description:\n              - Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE\n                environment variable.\n          key_file:\n              description:\n              - Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE\n                environment variable.\n          ssl_ca_cert:\n              description:\n              - Path to a CA certificate used to authenticate with the API. Can also be specified via\n                K8S_AUTH_SSL_CA_CERT environment variable.\n          verify_ssl:\n              description:\n              - \"Whether or not to verify the API server's SSL certificates. Can also be specified via\n                K8S_AUTH_VERIFY_SSL environment variable.\"\n              type: bool\n          namespaces:\n              description:\n              - List of namespaces. If not specified, will fetch all containers for all namespaces user is authorized\n                to access.\n\n    requirements:\n    - \"python >= 2.7\"\n    - \"openshift >= 0.6\"\n    - \"PyYAML >= 3.11\"\n'''\n\nEXAMPLES = '''\n# File must be named openshift.yaml or openshift.yml\n\n# Authenticate with token, and return all pods and services for all namespaces\nplugin: openshift\nconnections:\n    host: https:\/\/192.168.64.4:8443\n    token: xxxxxxxxxxxxxxxx\n    ssl_verify: false\n\n# Use default config (~\/.kube\/config) file and active context, and return objects for a specific namespace\nplugin: openshift\nconnections:\n    namespaces:\n    - testing\n\n# Use a custom config file, and a specific context.\nplugin: openshift\nconnections:\n  - kubeconfig: \/path\/to\/config\n    context: 'awx\/192-168-64-4:8443\/developer'\n'''\n\nfrom ansible.plugins.inventory.k8s import K8sInventoryException, InventoryModule as K8sInventoryModule, format_dynamic_api_exc\n\ntry:\n    from openshift.dynamic.exceptions import DynamicApiError\nexcept ImportError:\n    pass\n\n\nclass InventoryModule(K8sInventoryModule):\n    NAME = 'openshift'\n\n    transport = 'oc'\n\n    def fetch_objects(self, connections):\n        super(InventoryModule, self).fetch_objects(connections)\n        client = self.get_api_client()\n\n        if connections:\n            for connection in connections:\n                client = self.get_api_client(**connection)\n                name = connection.get('name', self.get_default_host_name(client.configuration.host))\n                if connection.get('namespaces'):\n                    namespaces = connection['namespaces']\n                else:\n                    namespaces = self.get_available_namespaces(client)\n                for namespace in namespaces:\n                    self.get_routes_for_namespace(client, name, namespace)\n        else:\n            name = self.get_default_host_name(client.configuration.host)\n            namespaces = self.get_available_namespaces(client)\n            for namespace in namespaces:\n                self.get_routes_for_namespace(client, name, namespace)\n\n    def get_routes_for_namespace(self, client, name, namespace):\n        v1_route = client.resources.get(api_version='v1', kind='Route')\n        try:\n            obj = v1_route.get(namespace=namespace)\n        except DynamicApiError as exc:\n            self.display.debug(exc)\n            raise K8sInventoryException('Error fetching Routes list: %s' % format_dynamic_api_exc(exc))\n\n        namespace_group = 'namespace_{0}'.format(namespace)\n        namespace_routes_group = '{0}_routes'.format(namespace_group)\n\n        self.inventory.add_group(name)\n        self.inventory.add_group(namespace_group)\n        self.inventory.add_child(name, namespace_group)\n        self.inventory.add_group(namespace_routes_group)\n        self.inventory.add_child(namespace_group, namespace_routes_group)\n        for route in obj.items:\n            route_name = route.metadata.name\n            route_annotations = {} if not route.metadata.annotations else dict(route.metadata.annotations)\n\n            self.inventory.add_host(route_name)\n\n            if route.metadata.labels:\n                # create a group for each label_value\n                for key, value in route.metadata.labels:\n                    group_name = 'label_{0}_{1}'.format(key, value)\n                    self.inventory.add_group(group_name)\n                    self.inventory.add_child(group_name, route_name)\n                route_labels = dict(route.metadata.labels)\n            else:\n                route_labels = {}\n\n            self.inventory.add_child(namespace_routes_group, route_name)\n\n            # add hostvars\n            self.inventory.set_variable(route_name, 'labels', route_labels)\n            self.inventory.set_variable(route_name, 'annotations', route_annotations)\n            self.inventory.set_variable(route_name, 'cluster_name', route.metadata.clusterName)\n            self.inventory.set_variable(route_name, 'object_type', 'route')\n            self.inventory.set_variable(route_name, 'self_link', route.metadata.selfLink)\n            self.inventory.set_variable(route_name, 'resource_version', route.metadata.resourceVersion)\n            self.inventory.set_variable(route_name, 'uid', route.metadata.uid)\n\n            if route.spec.host:\n                self.inventory.set_variable(route_name, 'host', route.spec.host)\n\n            if route.spec.path:\n                self.inventory.set_variable(route_name, 'path', route.spec.path)\n\n            if hasattr(route.spec.port, 'targetPort') and route.spec.port.targetPort:\n                self.inventory.set_variable(route_name, 'port', dict(route.spec.port))\n","license":"gpl-3.0","hash":-4194452294197962841,"line_mean":41.5154639175,"line_max":126,"alpha_frac":0.6314258002,"autogenerated":false}
{"repo_name":"reedox\/CSPTools","path":"proxy\/run.py","copies":"2","size":"1752","content":"#!\/usr\/bin\/python\n\nimport argparse\nimport re\nfrom CSPProxy import *\nimport traceback\n\ndefaultcsp = [\n    \"default-src 'none';\" +\n    \"script-src 'none';\" +\n    \"object-src 'none';\" +\n    \"img-src 'none';\" +\n    \"media-src 'none';\" +\n    \"style-src 'none';\" +\n    \"frame-src 'none';\" +\n    \"font-src 'none';\" +\n    \"connect-src 'none';\"\n][0]\n\ndefaultopencsp = [\n    \"default-src *;\" +\n    \"script-src none 'unsafe-inline' 'unsafe-eval';\" +\n    \"object-src *;\" +\n    \"img-src *\" +\n    \"media-src *;\" +\n    \"style-src * unsafe-inline;\" +\n    \"frame-src *;\" +\n    \"font-src *;\" +\n    \"connect-src *;\"\n][0]\n\n#Parse out arguments\nparser = argparse.ArgumentParser(description='Automagically adds a CSP header to all requests served through the proxy')\nparser.add_argument('-p', '--port', metavar='num', type=int, default=8080, help='Port to bind to', dest='port')\nparser.add_argument('-r', '--report', metavar='uri', default='\/csp.php', help='URI to send CSP reports to', dest='reporturi')\nparser.add_argument('-f', '--log', metavar='file', default='csp.log', help='File to log reports to', dest='logfile')\nparser.add_argument('-m', '--block', help='sets to proxy to use a blocking CSP', action='store_true')\nparser.add_argument('-o', '--host', metavar='host', default='www\\.example\\.com', help='Host regexp to inject csp headers into', dest='hostre')\nparser.add_argument('-c', '--csp', metavar='csp', default=defaultcsp, help='Set content security policy to use', dest='csp')\nargs = parser.parse_args()\n\nlog = open(args.logfile, 'a');\np = CSPProxy(args.csp, args.port, re.compile(args.hostre), args.reporturi, args.block, lambda r: log.write(r+\"\\n\"))\ntry:\n    p.run()\nexcept Exception as e:\n    print e\n    traceback.print_exc()\n    p.shutdown()\nlog.close()\n","license":"mit","hash":7710128108127860834,"line_mean":34.04,"line_max":142,"alpha_frac":0.6352739726,"autogenerated":false}
{"repo_name":"rafalmiel\/glmark2-wl","path":"waflib\/Tools\/fc_config.py","copies":"12","size":"9471","content":"#! \/usr\/bin\/env python\n# encoding: utf-8\n# WARNING! Do not edit! http:\/\/waf.googlecode.com\/git\/docs\/wafbook\/single.html#_obtaining_the_waf_file\n\nimport re,shutil,os,sys,string,shlex\nfrom waflib.Configure import conf\nfrom waflib.TaskGen import feature,after_method,before_method\nfrom waflib import Build,Utils\nFC_FRAGMENT='        program main\\n        end     program main\\n'\nFC_FRAGMENT2='        PROGRAM MAIN\\n        END\\n'\ndef fc_flags(conf):\n\tv=conf.env\n\tv['FC_SRC_F']=[]\n\tv['FC_TGT_F']=['-c','-o']\n\tv['FCINCPATH_ST']='-I%s'\n\tv['FCDEFINES_ST']='-D%s'\n\tif not v['LINK_FC']:v['LINK_FC']=v['FC']\n\tv['FCLNK_SRC_F']=[]\n\tv['FCLNK_TGT_F']=['-o']\n\tv['FCFLAGS_fcshlib']=['-fpic']\n\tv['LINKFLAGS_fcshlib']=['-shared']\n\tv['fcshlib_PATTERN']='lib%s.so'\n\tv['fcstlib_PATTERN']='lib%s.a'\n\tv['FCLIB_ST']='-l%s'\n\tv['FCLIBPATH_ST']='-L%s'\n\tv['FCSTLIB_ST']='-l%s'\n\tv['FCSTLIBPATH_ST']='-L%s'\n\tv['FCSTLIB_MARKER']='-Wl,-Bstatic'\n\tv['FCSHLIB_MARKER']='-Wl,-Bdynamic'\n\tv['SONAME_ST']='-Wl,-h,%s'\ndef check_fortran(self,*k,**kw):\n\tself.check_cc(fragment=FC_FRAGMENT,compile_filename='test.f',features='fc fcprogram',msg='Compiling a simple fortran app')\ndef check_fc(self,*k,**kw):\n\tkw['compiler']='fc'\n\tif not'compile_mode'in kw:\n\t\tkw['compile_mode']='fc'\n\tif not'type'in kw:\n\t\tkw['type']='fcprogram'\n\tif not'compile_filename'in kw:\n\t\tkw['compile_filename']='test.f90'\n\tif not'code'in kw:\n\t\tkw['code']=FC_FRAGMENT\n\treturn self.check(*k,**kw)\ndef fortran_modifier_darwin(conf):\n\tv=conf.env\n\tv['FCFLAGS_fcshlib']=['-fPIC','-compatibility_version','1','-current_version','1']\n\tv['LINKFLAGS_fcshlib']=['-dynamiclib']\n\tv['fcshlib_PATTERN']='lib%s.dylib'\n\tv['FRAMEWORKPATH_ST']='-F%s'\n\tv['FRAMEWORK_ST']='-framework %s'\n\tv['LINKFLAGS_fcstlib']=[]\n\tv['FCSHLIB_MARKER']=''\n\tv['FCSTLIB_MARKER']=''\n\tv['SONAME_ST']=''\ndef fortran_modifier_win32(conf):\n\tv=conf.env\n\tv['fcprogram_PATTERN']=v['fcprogram_test_PATTERN']='%s.exe'\n\tv['fcshlib_PATTERN']='%s.dll'\n\tv['implib_PATTERN']='lib%s.dll.a'\n\tv['IMPLIB_ST']='-Wl,--out-implib,%s'\n\tv['FCFLAGS_fcshlib']=[]\n\tv.append_value('FCFLAGS_fcshlib',['-DDLL_EXPORT'])\n\tv.append_value('LINKFLAGS',['-Wl,--enable-auto-import'])\ndef fortran_modifier_cygwin(conf):\n\tfortran_modifier_win32(conf)\n\tv=conf.env\n\tv['fcshlib_PATTERN']='cyg%s.dll'\n\tv.append_value('LINKFLAGS_fcshlib',['-Wl,--enable-auto-image-base'])\n\tv['FCFLAGS_fcshlib']=[]\ndef check_fortran_dummy_main(self,*k,**kw):\n\tif not self.env.CC:\n\t\tself.fatal('A c compiler is required for check_fortran_dummy_main')\n\tlst=['MAIN__','__MAIN','_MAIN','MAIN_','MAIN']\n\tlst.extend([m.lower()for m in lst])\n\tlst.append('')\n\tself.start_msg('Detecting whether we need a dummy main')\n\tfor main in lst:\n\t\tkw['fortran_main']=main\n\t\ttry:\n\t\t\tself.check_cc(fragment='int %s() { return 0; }\\n'%(main or'test'),features='c fcprogram',mandatory=True)\n\t\t\tif not main:\n\t\t\t\tself.env.FC_MAIN=-1\n\t\t\t\tself.end_msg('no')\n\t\t\telse:\n\t\t\t\tself.env.FC_MAIN=main\n\t\t\t\tself.end_msg('yes %s'%main)\n\t\t\tbreak\n\t\texcept self.errors.ConfigurationError:\n\t\t\tpass\n\telse:\n\t\tself.end_msg('not found')\n\t\tself.fatal('could not detect whether fortran requires a dummy main, see the config.log')\nGCC_DRIVER_LINE=re.compile('^Driving:')\nPOSIX_STATIC_EXT=re.compile('\\S+\\.a')\nPOSIX_LIB_FLAGS=re.compile('-l\\S+')\ndef is_link_verbose(self,txt):\n\tassert isinstance(txt,str)\n\tfor line in txt.splitlines():\n\t\tif not GCC_DRIVER_LINE.search(line):\n\t\t\tif POSIX_STATIC_EXT.search(line)or POSIX_LIB_FLAGS.search(line):\n\t\t\t\treturn True\n\treturn False\ndef check_fortran_verbose_flag(self,*k,**kw):\n\tself.start_msg('fortran link verbose flag')\n\tfor x in['-v','--verbose','-verbose','-V']:\n\t\ttry:\n\t\t\tself.check_cc(features='fc fcprogram_test',fragment=FC_FRAGMENT2,compile_filename='test.f',linkflags=[x],mandatory=True)\n\t\texcept self.errors.ConfigurationError:\n\t\t\tpass\n\t\telse:\n\t\t\tif self.is_link_verbose(self.test_bld.err)or self.is_link_verbose(self.test_bld.out):\n\t\t\t\tself.end_msg(x)\n\t\t\t\tbreak\n\telse:\n\t\tself.end_msg('failure')\n\t\tself.fatal('Could not obtain the fortran link verbose flag (see config.log)')\n\tself.env.FC_VERBOSE_FLAG=x\n\treturn x\nLINKFLAGS_IGNORED=[r'-lang*',r'-lcrt[a-zA-Z0-9\\.]*\\.o',r'-lc$',r'-lSystem',r'-libmil',r'-LIST:*',r'-LNO:*']\nif os.name=='nt':\n\tLINKFLAGS_IGNORED.extend([r'-lfrt*',r'-luser32',r'-lkernel32',r'-ladvapi32',r'-lmsvcrt',r'-lshell32',r'-lmingw',r'-lmoldname'])\nelse:\n\tLINKFLAGS_IGNORED.append(r'-lgcc*')\nRLINKFLAGS_IGNORED=[re.compile(f)for f in LINKFLAGS_IGNORED]\ndef _match_ignore(line):\n\tfor i in RLINKFLAGS_IGNORED:\n\t\tif i.match(line):\n\t\t\treturn True\n\treturn False\ndef parse_fortran_link(lines):\n\tfinal_flags=[]\n\tfor line in lines:\n\t\tif not GCC_DRIVER_LINE.match(line):\n\t\t\t_parse_flink_line(line,final_flags)\n\treturn final_flags\nSPACE_OPTS=re.compile('^-[LRuYz]$')\nNOSPACE_OPTS=re.compile('^-[RL]')\ndef _parse_flink_line(line,final_flags):\n\tlexer=shlex.shlex(line,posix=True)\n\tlexer.whitespace_split=True\n\tt=lexer.get_token()\n\ttmp_flags=[]\n\twhile t:\n\t\tdef parse(token):\n\t\t\tif _match_ignore(token):\n\t\t\t\tpass\n\t\t\telif token.startswith('-lkernel32')and sys.platform=='cygwin':\n\t\t\t\ttmp_flags.append(token)\n\t\t\telif SPACE_OPTS.match(token):\n\t\t\t\tt=lexer.get_token()\n\t\t\t\tif t.startswith('P,'):\n\t\t\t\t\tt=t[2:]\n\t\t\t\tfor opt in t.split(os.pathsep):\n\t\t\t\t\ttmp_flags.append('-L%s'%opt)\n\t\t\telif NOSPACE_OPTS.match(token):\n\t\t\t\ttmp_flags.append(token)\n\t\t\telif POSIX_LIB_FLAGS.match(token):\n\t\t\t\ttmp_flags.append(token)\n\t\t\telse:\n\t\t\t\tpass\n\t\t\tt=lexer.get_token()\n\t\t\treturn t\n\t\tt=parse(t)\n\tfinal_flags.extend(tmp_flags)\n\treturn final_flags\ndef check_fortran_clib(self,autoadd=True,*k,**kw):\n\tif not self.env.FC_VERBOSE_FLAG:\n\t\tself.fatal('env.FC_VERBOSE_FLAG is not set: execute check_fortran_verbose_flag?')\n\tself.start_msg('Getting fortran runtime link flags')\n\ttry:\n\t\tself.check_cc(fragment=FC_FRAGMENT2,compile_filename='test.f',features='fc fcprogram_test',linkflags=[self.env.FC_VERBOSE_FLAG])\n\texcept:\n\t\tself.end_msg(False)\n\t\tif kw.get('mandatory',True):\n\t\t\tconf.fatal('Could not find the c library flags')\n\telse:\n\t\tout=self.test_bld.err\n\t\tflags=parse_fortran_link(out.splitlines())\n\t\tself.end_msg('ok (%s)'%' '.join(flags))\n\t\tself.env.LINKFLAGS_CLIB=flags\n\t\treturn flags\n\treturn[]\ndef getoutput(conf,cmd,stdin=False):\n\tif stdin:\n\t\tstdin=Utils.subprocess.PIPE\n\telse:\n\t\tstdin=None\n\tenv=conf.env.env or None\n\ttry:\n\t\tp=Utils.subprocess.Popen(cmd,stdin=stdin,stdout=Utils.subprocess.PIPE,stderr=Utils.subprocess.PIPE,env=env)\n\t\tif stdin:\n\t\t\tp.stdin.write('\\n')\n\t\tstdout,stderr=p.communicate()\n\texcept:\n\t\tconf.fatal('could not determine the compiler version %r'%cmd)\n\telse:\n\t\tif not isinstance(stdout,str):\n\t\t\tstdout=stdout.decode(sys.stdout.encoding)\n\t\tif not isinstance(stderr,str):\n\t\t\tstderr=stderr.decode(sys.stdout.encoding)\n\t\treturn stdout,stderr\nROUTINES_CODE=\"\"\"\\\n      subroutine foobar()\n      return\n      end\n      subroutine foo_bar()\n      return\n      end\n\"\"\"\nMAIN_CODE=\"\"\"\nvoid %(dummy_func_nounder)s(void);\nvoid %(dummy_func_under)s(void);\nint %(main_func_name)s() {\n  %(dummy_func_nounder)s();\n  %(dummy_func_under)s();\n  return 0;\n}\n\"\"\"\ndef link_main_routines_tg_method(self):\n\tdef write_test_file(task):\n\t\ttask.outputs[0].write(task.generator.code)\n\tbld=self.bld\n\tbld(rule=write_test_file,target='main.c',code=MAIN_CODE%self.__dict__)\n\tbld(rule=write_test_file,target='test.f',code=ROUTINES_CODE)\n\tbld(features='fc fcstlib',source='test.f',target='test')\n\tbld(features='c fcprogram',source='main.c',target='app',use='test')\ndef mangling_schemes():\n\tfor u in['_','']:\n\t\tfor du in['','_']:\n\t\t\tfor c in[\"lower\",\"upper\"]:\n\t\t\t\tyield(u,du,c)\ndef mangle_name(u,du,c,name):\n\treturn getattr(name,c)()+u+(name.find('_')!=-1 and du or'')\ndef check_fortran_mangling(self,*k,**kw):\n\tif not self.env.CC:\n\t\tself.fatal('A c compiler is required for link_main_routines')\n\tif not self.env.FC:\n\t\tself.fatal('A fortran compiler is required for link_main_routines')\n\tif not self.env.FC_MAIN:\n\t\tself.fatal('Checking for mangling requires self.env.FC_MAIN (execute \"check_fortran_dummy_main\" first?)')\n\tself.start_msg('Getting fortran mangling scheme')\n\tfor(u,du,c)in mangling_schemes():\n\t\ttry:\n\t\t\tself.check_cc(compile_filename=[],features='link_main_routines_func',msg='nomsg',errmsg='nomsg',mandatory=True,dummy_func_nounder=mangle_name(u,du,c,\"foobar\"),dummy_func_under=mangle_name(u,du,c,\"foo_bar\"),main_func_name=self.env.FC_MAIN)\n\t\texcept self.errors.ConfigurationError:\n\t\t\tpass\n\t\telse:\n\t\t\tself.end_msg(\"ok ('%s', '%s', '%s-case')\"%(u,du,c))\n\t\t\tself.env.FORTRAN_MANGLING=(u,du,c)\n\t\t\tbreak\n\telse:\n\t\tself.end_msg(False)\n\t\tself.fatal('mangler not found')\n\treturn(u,du,c)\ndef set_lib_pat(self):\n\tself.env['fcshlib_PATTERN']=self.env['pyext_PATTERN']\ndef detect_openmp(self):\n\tfor x in['-fopenmp','-openmp','-mp','-xopenmp','-omp','-qsmp=omp']:\n\t\ttry:\n\t\t\tself.check_fc(msg='Checking for OpenMP flag %s'%x,fragment='program main\\n  call omp_get_num_threads()\\nend program main',fcflags=x,linkflags=x,uselib_store='OPENMP')\n\t\texcept self.errors.ConfigurationError:\n\t\t\tpass\n\t\telse:\n\t\t\tbreak\n\telse:\n\t\tself.fatal('Could not find OpenMP')\n\nconf(fc_flags)\nconf(check_fortran)\nconf(check_fc)\nconf(fortran_modifier_darwin)\nconf(fortran_modifier_win32)\nconf(fortran_modifier_cygwin)\nconf(check_fortran_dummy_main)\nconf(is_link_verbose)\nconf(check_fortran_verbose_flag)\nconf(check_fortran_clib)\nfeature('link_main_routines_func')(link_main_routines_tg_method)\nbefore_method('process_source')(link_main_routines_tg_method)\nconf(check_fortran_mangling)\nfeature('pyext')(set_lib_pat)\nbefore_method('propagate_uselib_vars','apply_link')(set_lib_pat)\nconf(detect_openmp)","license":"gpl-3.0","hash":1356593734253040651,"line_mean":32.4699646643,"line_max":241,"alpha_frac":0.6868334917,"autogenerated":false}
{"repo_name":"UKTradeInvestment\/crm-poc","path":"crm-poc\/apps\/migrator\/models.py","copies":"1","size":"4551","content":"from contextlib import ContextDecorator\n\nfrom django.db import models, transaction\n\nfrom core.lib_models import TimeStampedModel\n\n\nclass override_skip_cdms(ContextDecorator):\n    \"\"\"\n    Context Manager used to temporarily override the _cdms_skip\n    class attribute with the `overriding_skip_cdms` given.\n    \"\"\"\n    def __init__(self, obj, overriding_skip_cdms):\n        self.obj = obj\n        self.overriding_skip_cdms = overriding_skip_cdms\n\n    def __enter__(self):\n        self.original_skip_cdms = self.obj._cdms_skip\n        self.obj._cdms_skip = self.overriding_skip_cdms\n        return self\n\n    def __exit__(self, *exc):\n        self.obj._cdms_skip = self.original_skip_cdms\n        del self.original_skip_cdms\n        return False\n\n\nclass CDMSModel(TimeStampedModel):\n    cdms_pk = models.CharField(max_length=255, blank=True)\n\n    cdms_migrator = None  # should be subclass of migrator.cdms_migrator.BaseCDMSMigrator\n\n    def __init__(self, *args, **kwargs):\n        super(CDMSModel, self).__init__(*args, **kwargs)\n        self._cdms_skip = False\n\n    def save(self, *args, **kwargs):\n        overriding_skip_cdms = kwargs.pop('skip_cdms', self._cdms_skip)\n        with override_skip_cdms(self, overriding_skip_cdms):\n            return super(CDMSModel, self).save(*args, **kwargs)\n\n    def _do_insert(self, manager, using, fields, update_pk, raw):\n        if self._cdms_skip:\n            manager = manager.skip_cdms()\n        return super(CDMSModel, self)._do_insert(manager, using, fields, update_pk, raw)\n\n    def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):\n        \"\"\"\n        This method will try to update the model. If the model was updated (in\n        the sense that an update query was done and a matching row was found\n        from the DB) the method will return True.\n\n        NOTE: this is copy\/paste from Django +\n        - cmd_skip if requested\n        - call to _update_with_modified instead of _update to make clear that it's a new method not the\n            django one\n        \"\"\"\n        if self._cdms_skip:\n            base_qs = base_qs.skip_cdms()\n\n        filtered = base_qs.filter(pk=pk_val)\n        if not values:\n            # We can end up here when saving a model in inheritance chain where\n            # update_fields doesn't target any field in current model. In that\n            # case we just say the update succeeded. Another case ending up here\n            # is a model with just PK - in that case check that the PK still\n            # exists.\n            return update_fields is not None or filtered.exists()\n        if self._meta.select_on_save and not forced_update:\n            if filtered.exists():\n                # It may happen that the object is deleted from the DB right after\n                # this check, causing the subsequent UPDATE to return zero matching\n                # rows. The same result can occur in some rare cases when the\n                # database returns zero despite the UPDATE being executed\n                # successfully (a row is matched and updated). In order to\n                # distinguish these two cases, the object's existence in the\n                # database is again checked for if the UPDATE query returns 0.\n                n_records, modified = filtered._update_with_modified(values)\n                if modified:\n                    self.modified = modified\n                return n_records > 0 or filtered.exists()\n            else:\n                return False\n\n        n_records, modified = filtered._update_with_modified(values)\n        if modified:\n            self.modified = modified\n        return n_records > 0\n\n    def _do_delete_cdms_obj(self):\n        \"\"\"\n        Private method which only deletes the cdms object. Not meant to be used publicly.\n        \"\"\"\n        from .query import DeleteQuery\n\n        assert self.cdms_pk, \\\n            \"%s object can't be deleted because its cdms_pk attribute is not set.\" % self._meta.object_name\n\n        query = DeleteQuery(self.__class__)\n        query.set_cdms_pk(self.cdms_pk)\n        query.get_compiler().execute()\n\n    def delete(self, *args, **kwargs):\n        ret = None\n        overriding_skip_cdms = kwargs.pop('skip_cdms', self._cdms_skip)\n        with override_skip_cdms(self, overriding_skip_cdms):\n            with transaction.atomic():\n                ret = super(CDMSModel, self).delete(*args, **kwargs)\n\n                if not self._cdms_skip:\n                    self._do_delete_cdms_obj()\n\n        return ret\n\n    class Meta:\n        abstract = True\n","license":"bsd-3-clause","hash":-8038274811556306516,"line_mean":38.2327586207,"line_max":107,"alpha_frac":0.6134915403,"autogenerated":false}
{"repo_name":"back-to\/streamlink","path":"src\/streamlink\/plugins\/bfmtv.py","copies":"1","size":"1630","content":"import re\n\nfrom streamlink.plugin import Plugin\nfrom streamlink.plugins.brightcove import BrightcovePlayer\nfrom streamlink.stream import HLSStream\n\n\nclass BFMTV(Plugin):\n    _url_re = re.compile(r'https:\/\/.+\\.(?:bfmtv|01net)\\.com')\n    _brightcove_video_re = re.compile(r'data-holder=\"video(?P<video_id>[0-9]+)\" data-account=\"(?P<account_id>[0-9]+)\"')\n    _brightcove_video_alt_re = re.compile(r'data-account=\"(?P<account_id>[0-9]+).*?data-video-id=\"(?P<video_id>[0-9]+)\"')\n    _embed_video_url_re = re.compile(r\"\\$YOPLAYER\\('liveStitching', {.+?file: '(?P<video_url>[^\\\"]+?)'.+?}\\);\", re.DOTALL)\n\n    @classmethod\n    def can_handle_url(cls, url):\n        return BFMTV._url_re.match(url)\n\n    def _get_streams(self):\n        # Retrieve URL page and search for Brightcove video data\n        res = self.session.http.get(self.url)\n        match = self._brightcove_video_re.search(res.text) or self._brightcove_video_alt_re.search(res.text)\n        if match is not None:\n            account_id = match.group('account_id')\n            video_id = match.group('video_id')\n            player = BrightcovePlayer(self.session, account_id)\n            for stream in player.get_streams(video_id):\n                yield stream\n        else:\n            # Try to get the stream URL in the page\n            match = self._embed_video_url_re.search(res.text)\n            if match is not None:\n                video_url = match.group('video_url')\n                if '.m3u8' in video_url:\n                    for stream in HLSStream.parse_variant_playlist(self.session, video_url).items():\n                        yield stream\n\n\n__plugin__ = BFMTV\n","license":"bsd-2-clause","hash":4128592783275707247,"line_mean":41.8947368421,"line_max":122,"alpha_frac":0.6055214724,"autogenerated":false}
{"repo_name":"RevSquare\/rs_sections","path":"rs_sections\/managers.py","copies":"1","size":"1858","content":"from django.contrib.contenttypes.models import ContentType\nfrom django.db import models\n\n\nclass ContentTypeQuerySet(models.QuerySet):\n\n    def _get_ct(self, obj):\n        \"\"\"\n        :param obj: register django model\n        :return: ContentType for model\n        \"\"\"\n        return ContentType.objects.get_for_model(obj.__class__)\n\n\nclass SectionQuerySet(ContentTypeQuerySet):\n    \"\"\"\n    QuerySet to section model :class: sections.models.Section\n    will be used as manager to it\n    \"\"\"\n\n    def get_by_system_name(self, slug):\n        \"\"\"\n        :param slug: string\n        :return: Section :class:sections.models.Section instance\n        \"\"\"\n        return self.get(system_name=slug)\n\n    def main_sections(self, system_names=None):\n        \"\"\"\n        List of sections not related to object\n        :param system_names: list of system names\n        :return: queryset\n        \"\"\"\n        queryset = self.filter(content_type__isnull=True)\n        if system_names:\n            queryset = queryset.filter(system_name__in=system_names)\n        return queryset\n\n    def object_sections(self, obj=None):\n        \"\"\"\n        Llist of sections related to objects only\n        :return: queryset\n        \"\"\"\n        if obj is None:\n            return self.filter(content_type__isnull=False)\n        else:\n            ct = self._get_ct(obj)\n            return self.filter(content_type=ct, object_id=obj.pk)\n\n\nclass SectionItemQuerySet(ContentTypeQuerySet):\n    \"\"\"\n    Queryset for :class: `sections.models.SectionItem`\n    will be used as manager\n    \"\"\"\n\n    def for_object(self, obj):\n        \"\"\"\n        return all section items related to given obj\n\n        :param obj: register django model\n        :return: queryset\n        \"\"\"\n\n        ct = self._get_ct(obj)\n        return self.filter(\n            content_type=ct,\n            object_id=obj.pk\n        )\n","license":"bsd-3-clause","hash":-2995596654859910888,"line_mean":25.9275362319,"line_max":68,"alpha_frac":0.6006458558,"autogenerated":false}
