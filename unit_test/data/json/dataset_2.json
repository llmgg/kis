{"repo_name":"jadatkins\/python-lazylist","path":"lazylist.py","copies":"1","size":"3673","content":"#!\/usr\/bin\/env python3\n\nfrom collections.abc import Sequence, Iterator\n\n__all__ = ['LazyList', 'LazyListIterator']\n\nclass LazyList(Sequence):\n    def __init__(self, iterable):\n        self._data = list()\n        self._iter = iter(iterable)\n        self._exhausted = False\n\n    def __iter__(self):\n        return LazyListIterator(self)\n\n    def __bool__(self):\n        try:\n            self[0]\n        except IndexError:\n            return False\n        else:\n            return True\n\n    def __len__(self):\n        self._exhaust()\n        return len(self._data)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            for s in (key.start, key.stop, key.step):\n                if not (s is None or isinstance(s, int)):\n                    raise TypeError(\"lazy-list slice indeces must be integers\")\n        elif not isinstance(key, int):\n            raise TypeError(\"lazy-list key must be an integer or a slice\")\n\n        def negative(k):\n            if isinstance(k, int):\n                return k < 0\n            if isinstance(k, slice):\n                negative_start = k.start is not None and k.start < 0\n                negative_stop  = k.stop  is not None and k.stop  < 0\n                return negative_start or negative_stop\n\n        if negative(key):\n            self._exhaust()\n            return self._data[key]\n\n        if isinstance(key, slice):\n            return LazyListIterator(self, key)\n\n        if isinstance(key, int):\n            while True:\n                try:\n                    return self._data[key]\n                except IndexError:\n                    try:\n                        self._tick()\n                    except StopIteration:\n                        raise IndexError(\"lazy-list index out of range\") from None\n\n    def _exhaust(self):\n        for item in self._iter:\n            self._data.append(item)\n        self._exhausted = True\n\n    def _tick(self):\n        try:\n            item = next(self._iter)\n        except StopIteration as err:\n            self._exhausted = True\n            raise err\n        else:\n            self._data.append(item)\n            return item\n\n    def __repr__(self):\n        if self._exhausted:\n            return \"{}({})\".format(\n                type(self).__name__, repr(self._data))\n        elif len(self._data) < 1:\n            return \"{}({})\".format(\n                type(self).__name__, repr(self._iter))\n        else:\n            return \"{}({}... ] + {})\".format(\n                type(self).__name__, repr(self._data)[:-1], repr(self._iter))\n\n\nclass LazyListIterator(Iterator):\n    def __init__(self, source, key=slice(None, None, None)):\n        super().__init__()\n        if not hasattr(source, '__getitem__'):\n            raise TypeError(\"LazyListIterator(): source must be a Sequence\")\n        if not isinstance(key, slice):\n            raise TypeError(\"LazyListIterator(): key must be a slice\")\n        if key.step == 0:\n            raise ValueError(\"slice step cannot be zero\")\n        self._source = source\n        self._cursor = 0 if key.start is None else key.start\n        self._stop   = key.stop\n        self._step   = 1 if key.step is None else key.step\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._stop is not None:\n            if self._step > 0 and self._cursor >= self._stop:\n                raise StopIteration\n            if self._step < 0 and self._cursor <= self._stop:\n                raise StopIteration\n        try:\n            item = self._source[self._cursor]\n        except IndexError:\n            raise StopIteration from None\n        else:\n            self._cursor += self._step\n            return item\n","license":"mit","hash":8781106323394438819,"line_mean":30.3931623932,"line_max":82,"alpha_frac":0.5104818949,"autogenerated":false}
{"repo_name":"wilsonianb\/nacl_contracts","path":"tests\/testutils.py","copies":"8","size":"1153","content":"\n# Copyright 2009  The Native Client Authors.  All rights reserved.\n# Use of this source code is governed by a BSD-style license that can\n# be found in the LICENSE file.\n\nimport shutil\nimport subprocess\nimport tempfile\nimport unittest\n\n\n# From http:\/\/lackingrhoticity.blogspot.com\/2008\/11\/tempdirtestcase-python-unittest-helper.html\nclass TempDirTestCase(unittest.TestCase):\n\n  def setUp(self):\n    self._on_teardown = []\n\n  def make_temp_dir(self):\n    temp_dir = tempfile.mkdtemp(prefix=\"tmp-%s-\" % self.__class__.__name__)\n    def tear_down():\n      shutil.rmtree(temp_dir)\n    self._on_teardown.append(tear_down)\n    return temp_dir\n\n  def tearDown(self):\n    for func in reversed(self._on_teardown):\n      func()\n\n\ndef write_file(filename, data):\n  fh = open(filename, \"w\")\n  try:\n    fh.write(data)\n  finally:\n    fh.close()\n\n\ndef read_file(filename):\n  fh = open(filename, \"r\")\n  try:\n    return fh.read()\n  finally:\n    fh.close()\n\n\n# TODO: use subprocess.check_call when we have Python 2.5 on Windows.\ndef check_call(*args, **kwargs):\n  rc = subprocess.call(*args, **kwargs)\n  if rc != 0:\n    raise Exception(\"Failed with return code %i\" % rc)\n","license":"bsd-3-clause","hash":-7998730821623122667,"line_mean":22.06,"line_max":95,"alpha_frac":0.6799653079,"autogenerated":false}
{"repo_name":"jmichelsen\/py-lepton","path":"examples\/fire.py","copies":"6","size":"2176","content":"#############################################################################\n#\n# Copyright (c) 2008 by Casey Duncan and contributors\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the MIT License\n# A copy of the license should accompany this distribution.\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n#\n#############################################################################\n\"\"\"Fire simulation using point sprites\"\"\"\n\n__version__ = '$Id$'\n\nimport os\nfrom pyglet import image\nfrom pyglet.gl import *\n\nfrom lepton import Particle, ParticleGroup, default_system\nfrom lepton.renderer import PointRenderer\nfrom lepton.texturizer import SpriteTexturizer, create_point_texture\nfrom lepton.emitter import StaticEmitter\nfrom lepton.domain import Line\nfrom lepton.controller import Gravity, Lifetime, Movement, Fader, ColorBlender\n\nwin = pyglet.window.Window(resizable=True, visible=False)\nwin.clear()\n\nglEnable(GL_BLEND)\nglShadeModel(GL_SMOOTH)\nglBlendFunc(GL_SRC_ALPHA,GL_ONE)\nglDisable(GL_DEPTH_TEST)\n\nflame = StaticEmitter(\n\trate=500,\n\ttemplate=Particle(\n\t\tposition=(300,25,0), \n\t\tvelocity=(0,0,0), \n\t\tcolor=(1,1,1,1),\n\t),\n\tposition=Line((win.width\/2 - 85, -15, 0), (win.width\/2 + 85, -15, 0)),\n\tdeviation=Particle(position=(10,0,0), velocity=(7,50,0), age=0.75)\n)\n\ndefault_system.add_global_controller(\n\tLifetime(6),\n\tGravity((0,20,0)), \n\tMovement(), \n\tColorBlender(\n\t\t[(0, (0,0,0.5,0)), \n\t\t(0.5, (0,0,0.5,0.2)), \n\t\t(0.75, (0,0.5,1,0.6)), \n\t\t(1.5, (1,1,0,0.2)), \n\t\t(2.7, (0.9,0.2,0,0.4)), \n\t\t(3.2, (0.6,0.1,0.05,0.2)), \n\t\t(4.0, (0.8,0.8,0.8,0.1)),\n\t\t(6.0, (0.8,0.8,0.8,0)), ]\n\t),\n)\n\ngroup = ParticleGroup(controllers=[flame], \n\trenderer=PointRenderer(64, SpriteTexturizer(create_point_texture(64, 5))))\n\nwin.set_visible(True)\npyglet.clock.schedule_interval(default_system.update, (1.0\/30.0))\npyglet.clock.set_fps_limit(None)\n\n@win.event\ndef on_draw():\n\twin.clear()\n\tglLoadIdentity()\n\tdefault_system.draw()\n\nif __name__ == '__main__':\n\tdefault_system.run_ahead(2, 30)\n\tpyglet.app.run()\n","license":"mit","hash":5132382890803814215,"line_mean":26.8974358974,"line_max":78,"alpha_frac":0.6493566176,"autogenerated":false}
{"repo_name":"wdwvt1\/qiime","path":"tests\/test_detrend.py","copies":"15","size":"6329","content":"#!\/usr\/bin\/env python\n\n\"\"\"Tests of code for detrending\"\"\"\n\n__author__ = \"Dan Knights\"\n__copyright__ = \"Copyright 2012, The QIIME Project\"\n# remember to add yourself if you make changes\n__credits__ = [\"Dan Knights\"]\n__license__ = \"GPL\"\n__version__ = \"1.9.1-dev\"\n__maintainer__ = \"Dan Knights\"\n__email__ = \"daniel.knights@colorado.edu\"\n\n\nfrom os import remove, system, close\nfrom shutil import rmtree\nfrom os.path import join, exists\nfrom tempfile import NamedTemporaryFile, mkdtemp, mkstemp\n\nfrom unittest import TestCase, main\nfrom burrito.util import ApplicationError\n\nfrom skbio.util import remove_files\nfrom qiime.detrend import detrend_pcoa\nfrom numpy import array\n\n\ndef is_float(input_string):\n    \"\"\"True if string can be cast as a float\"\"\"\n    try:\n        float(input_string)\n        return True\n    except ValueError:\n        return False\n\n\nclass DetrendTests(TestCase):\n\n    \"\"\"Tests of the RSupervisedLearner class\"\"\"\n\n    def setUp(self):\n\n        # Temporary input file\n        fd, self.tmp_pc_fp = mkstemp(prefix='R_test_pcoa',\n                                    suffix='.txt')\n        close(fd)\n        seq_file = open(self.tmp_pc_fp, 'w')\n        seq_file.write(test_pc)\n        seq_file.close()\n\n        fd, self.tmp_map_fp = mkstemp(prefix='R_test_map_',\n                                     suffix='.txt')\n        close(fd)\n        map_file = open(self.tmp_map_fp, 'w')\n        map_file.write(test_map)\n        map_file.close()\n\n        self.files_to_remove = \\\n            [self.tmp_pc_fp, self.tmp_map_fp]\n\n        # Prep input files in R format\n        self.output_dir = mkdtemp()\n        self.dirs_to_remove = [self.output_dir]\n\n        # get detrending results\n#         mkdir(join(self.output_dir, 'random_forest'))\n#         self.results = RSupervisedLearner()(\n#             self.tmp_otu_fp, self.tmp_map_fp,'Individual',\n#             ntree=100, errortype='oob',\n#             output_dir=self.output_dir)\n\n    def tearDown(self):\n        return\n        remove_files(set(self.files_to_remove))\n        # remove directories last, so we don't get errors\n        # trying to remove files which may be in the directories\n        for d in self.dirs_to_remove:\n            if exists(d):\n                rmtree(d)\n\n    def test_detrend_no_gradient(self):\n        \"\"\"Ensure that detrending runs and produces expected files\n           with no associated gradient.\n\n        \"\"\"\n        results = detrend_pcoa(input_fp=self.tmp_pc_fp,\n                               map_fp=None, gradient_variable=None,\n                               suppress_prerotate=False, output_dir=self.output_dir,\n                               HALT_EXEC=False)\n        self.assertEqual(results['summary'], None)\n        coords = results['coords']\n        lines = coords.readlines()\n\n        # ensure one line per sample in detrended pcoa\n        self.assertEqual(len(lines), len(test_pc.split('\\n')) - 4)\n        # ensure three columns tab delimited\n        self.assertEqual(len(lines[0].split('\\t')), 3)\n\n    def test_detrend_gradient(self):\n        \"\"\"Ensure that detrending runs and produces expected files\n           with associated gradient.\n\n        \"\"\"\n        results = detrend_pcoa(input_fp=self.tmp_pc_fp,\n                               map_fp=self.tmp_map_fp, gradient_variable='Gradient',\n                               suppress_prerotate=False, output_dir=self.output_dir,\n                               HALT_EXEC=False)\n\n        # check formatting of summary file\n        lines = results['summary'].readlines()\n        self.assertEqual(len(lines), 4)\n\n        # check formatting of coords file\n        lines = results['coords'].readlines()\n        # ensure one line per sample in detrended pcoa\n        self.assertEqual(len(lines), len(test_pc.split('\\n')) - 4)\n        # ensure three columns tab delimited\n        self.assertEqual(len(lines[0].split('\\t')), 3)\n\n        # ensure that plot pdf is at least present\n        self.assertEqual(str(type(results['plot'])), \"<type 'file'>\")\n\n    def test_detrend_gradient_no_prerotate(self):\n        \"\"\"Ensure that detrending runs and produces expected files\n           with associated gradient.\n\n        \"\"\"\n        results = detrend_pcoa(input_fp=self.tmp_pc_fp,\n                               map_fp=self.tmp_map_fp, gradient_variable='Gradient',\n                               suppress_prerotate=True, output_dir=self.output_dir,\n                               HALT_EXEC=False)\n\n        # check formatting of summary file\n        lines = results['summary'].readlines()\n        self.assertEqual(len(lines), 4)\n\n        # check formatting of coords file\n        lines = results['coords'].readlines()\n        # ensure one line per sample in detrended pcoa\n        self.assertEqual(len(lines), len(test_pc.split('\\n')) - 4)\n        # ensure three columns tab delimited\n        self.assertEqual(len(lines[0].split('\\t')), 3)\n\n        # ensure that plot pdf is at least present\n        self.assertEqual(str(type(results['plot'])), \"<type 'file'>\")\n\n\ntest_pc = \\\n    \"\"\"pc vector number\t1\t2\noutsidemouthT1.U1.536668\t-0.259989511\t0.031981421\noutsidemouthT1.U2.536736\t-0.10770442\t0.00760908\noutsidemouthT2.U1.536267\t0.007775311\t0.085673368\noutsidemouthT2.U2.536494\t0.096648247\t0.11165307\noutsidemouthT3.U1.536512\t0.060330843\t0.097689673\noutsidemouthT3.U2.536209\t0.086096188\t0.120917046\noutsidemouthT4.U1.536532\t0.104765697\t-0.005655307\noutsidemouthT4.U2.536258\t0.154786488\t0.146644973\noutsidemouthT5.U1.536645\t0.111274125\t-0.016418682\noutsidemouthT5.U2.536511\t0.09092745\t-0.03218781\noutsidemouthT6.U1.536444\t0.070454432\t-0.212724803\noutsidemouthT6.U2.536486\t0.067498055\t-0.241014047\noutsidemouthT7.U1.536739\t0.030952249\t-0.260790565\noutsidemouthT7.U2.536211\t0.031283845\t-0.262058153\n\neigvals\t2.231000323\t1.471086217\n% variation explained\t22.05856065\t14.54506492\n\"\"\"\n\ntest_map = \\\n    \"\"\"#SampleID\tGradient\noutsidemouthT1.U1.536668\t10\noutsidemouthT1.U2.536736\t20\noutsidemouthT2.U1.536267\t15\noutsidemouthT2.U2.536494\t25\noutsidemouthT3.U1.536512\t10\noutsidemouthT3.U2.536209\t10\noutsidemouthT4.U1.536532\t30\noutsidemouthT4.U2.536258\t35\noutsidemouthT5.U1.536645\t1000\noutsidemouthT5.U2.536511\t18\noutsidemouthT6.U1.536444\t17\noutsidemouthT6.U2.536486\t16\noutsidemouthT7.U1.536739\t12\noutsidemouthT7.U2.536211\t11\n\"\"\"\n\n# run unit tests if run from command-line\nif __name__ == '__main__':\n    main()\n","license":"gpl-2.0","hash":-1247017677630757724,"line_mean":32.4867724868,"line_max":84,"alpha_frac":0.6337494075,"autogenerated":false}
{"repo_name":"rolisz\/walter_waiter","path":"event.py","copies":"1","size":"4762","content":"import Queue\nfrom threading import Thread, Event\nfrom time import sleep\n\n\nclass EventLoop(object):\n\n\n    def __init__(self):\n        self.registry = {}\n        self.threads = {}\n        self.queue = Queue.Queue()\n        self.run_flag = Event()\n        self.run_flag.set()\n\n\n    def register(self, name, thread_obj=None, event=None):\n        \"\"\"\n        If called with two parameters, they should be event to listen to and\n        the EventConsumer class that will listen to it.\n        If called with one parameter, it should be an EventEmitter class.\n        \"\"\"\n        if thread_obj is not None:\n            self.threads[name] = thread_obj\n        if event is not None:\n            if event not in self.registry:\n                self.registry[event] = []\n            if self.threads[name].add_event not in self.registry[event]:\n                self.registry[event].append(self.threads[name].add_event)\n\n\n    def unregister(self, event, name):\n        ev_thr = self.threads[name].add_event\n        print('unregister', event, name, ev_thr, self.registry[event])\n        if ev_thr in self.registry[event]:\n            self.registry[event].remove(ev_thr)\n            print(self.registry[event])\n\n\n    def add_event(self, event, value):\n        self.queue.put((event, value))\n\n\n    def run(self):\n        for name in self.threads:\n            self.threads[name].start()\n        while True:\n            try:\n                event, value = self.queue.get(True, 20)\n                if event == 'unregister':\n                    self.unregister(*value)\n                if event not in self.registry:\n                    print(\"Invalid event encountered %s with values %r!\" %\n                          (event, value))\n                for listener in self.registry[event]:\n                    # print('call', listener, event, value)\n                    listener(event, value)\n            except KeyboardInterrupt:\n                self.run_flag.clear()\n                for thread in self.threads:\n                    print(thread)\n                    self.threads[thread].join()\n                return\n            except Queue.Empty:\n                pass\n\n\nclass EventEmitter(Thread):\n\n    def __init__(self, ev):\n        self.ev = ev\n        self.run_flag = ev.run_flag\n        super(EventEmitter, self).__init__()\n\n    def emit(self, event, values=None):\n        self.ev.add_event(event, values)\n\n\nclass EventConsumer(Thread):\n\n    def __init__(self, flag=None):\n        self.queue = Queue.Queue()\n        if flag is not None:\n            self.run_flag = flag\n        super(EventConsumer, self).__init__()\n\n\n    def add_event(self, event, value):\n        self.queue.put((event, value))\n\n\n    def sleep(self, time):\n        sleep(time)\n        event = None\n        value = None\n        while True:\n            try:\n                event, value = self.queue.get(False)\n            except Queue.Empty:\n                #try:\n                #    if event is not None:\n                #        self.queue.put((event, value))\n                #except AttributeError:\n                #    print(\"Unfound attribute %s\" % event)\n                break\n\n    def run(self):\n        while self.run_flag.is_set():\n            try:\n                event, value = self.queue.get(True, 2)\n                getattr(self, event)(value)\n            except Queue.Empty:\n                pass\n\nclass DecisionMaker(EventEmitter, EventConsumer):\n\n    def __init__(self, ev):\n        EventEmitter.__init__(self, ev)\n        EventConsumer.__init__(self)\n\n\ndef main():\n    from time import sleep\n    from random import random\n\n    class Producer(EventEmitter):\n        def __init__(self, ev, i):\n            self.i = i\n            super(Producer, self).__init__(ev)\n\n        def run(self):\n            for i in range(20):\n                if not self.run_flag.is_set():\n                    break\n                self.emit(self.i, i)\n                sleep(random())\n\n    class Consumer(EventConsumer):\n        def __init__(self, ev, i):\n            self.i = i\n            self.ev = ev\n            super(Consumer, self).__init__(ev.run_flag)\n\n        def event1(self, value):\n            print('event1', value, self.i)\n\n        def event2(self, value):\n            print('event2', value, self.i)\n            if value == 10:\n                self.ev.unregister('event1', 'c3')\n                # self.ev.add_event('unregister', ('event1', 'c3'))\n\n    e = EventLoop()\n\n    e.register(\"p1\", Producer(e, 'event1'))\n    e.register(\"p2\", Producer(e, 'event1'))\n    e.register(\"p3\", Producer(e, 'event2'))\n\n    e.register('c1', Consumer(e, 'c1'), 'event1')\n    e.register('c2', Consumer(e, 'c2'), 'event2')\n    e.register('c3', Consumer(e, 'c3'), 'event1')\n\n\n    e.run()\n\nif __name__ == '__main__':\n    main()\n","license":"mit","hash":-4546691486602370974,"line_mean":27.5149700599,"line_max":76,"alpha_frac":0.517849643,"autogenerated":false}
